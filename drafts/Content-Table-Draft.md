# 目录草稿

# 参考A：

## 第1章 设计与约束 —— 嵌入式系统中写 C++ 的思维模型

- 嵌入式的资源与实时约束（Flash/ROM、RAM、CPU、功耗、启动时间、确定性）
- 语言选择原则：何时用 C++、用哪些 C++ 特性（折中与禁用项）
- 性能 vs 可维护性的真实取舍
- 编码规范建议（小型嵌入式友好的 C++ 子集／风格指南）
- 练习：评估三个小示例（用 C、用 C++（面向对象），比较代码大小与性能）

**章末速查**：适用/禁用的 C++ 特性清单

------

## 第2章 工具链与构建（为性能调优打基础）

- 交叉编译基础与 CMake 多目标构建
- 常用编译器选项（-O0/-Og/-O2/-Os/-Ofast、-fno-exceptions、-fno-rtti、-ffunction-sections/ -fdata-sections、-Wl,--gc-sections）
- 链接器与 LTO/ThinLTO，影响代码大小与性能的链接策略
- 链接脚本（Memory、FLASH/RAM 布局、.bss/.data/.rodata）
- 启动代码与初始化顺序（全局构造、构造开销）
- 练习：建立最小 cross-build pipeline + 分析二进制节大小

------

## 第3章 编译期技术 —— 把工作尽量移到编译时

- `constexpr`（C++11/14/17/20）与设计技巧：常量表达式计算、lookup tables、编译期字符串处理
- `consteval`、`constinit`（C++20）
- 模板元编程（TMP）基础与实用模式（编译期映射、选择实现）
- `static_assert`、SFINAE、`if constexpr`
- 练习：实现一个编译期 CRC 表或小型 FSM，并比较运行时 vs 编译期实现差异

------

## 第4章 现代类型与轻量容器（内存控制的武器库）

- `std::span`、`std::string_view`、`string_ref` 的使用场景与零拷贝设计
- `std::array`、`std::optional`、`std::variant` 在嵌入式的适用性与成本
- small-buffer-optimization 思路（small-vector）
- `std::pmr` / 自定义分配器（内嵌池、紧凑分配）——何时使用，何时避免
- 练习：实现一个固定容量的 `small_vector<T>` 并在 ISR/线程间测试

------

## 第5章 内存管理与性能（嵌入式的黄金法则）

- 内存布局（静态、堆、栈）、碎片化与内存对齐
- 固定池 / slab / arena 分配器实现与比较
- 禁用 heap 或限制 heap 时的替代策略：对象池、栈分配、placement new
- 避免动态分配的 API 设计模式
- 练习：实现并 benchmark 一个固定大小对象池（含多线程安全版本）

------

## 第6章 所有权与资源管理 —— RAII 实战

- RAII 在驱动/外设管理中的应用（GPIO、SPI、DMA、文件句柄）
- `unique_ptr`、`shared_ptr` 的嵌入式取舍（内存成本、控制周期）
- intrusive 智能指针与引用计数（非堆实现）
- 练习：用 RAII 封装外设初始化/关闭流程（支持异常与无异常两套策略）

------

## 第7章 异常、RTTI 与错误处理策略

- 为什么在多数嵌入式场景下禁用异常（或限定使用）
- 替代方案：`expected`/`outcome`/错误码、`std::optional`、结果类型封装
- RTTI 的成本与替代（静态多态、CRTP）
- 练习：把一个使用异常的库改造为返回 `Result<T, E>` 的风格

------

## 第8章 并发、原子与内存模型（从裸机到 Linux）

- C++ 内存模型简介（顺序一致性、释放/获取语义）
- `std::atomic`、原子操作、内存栅栏在嵌入式的使用
- 轻量同步：自旋锁、信号量、条件变量的代价（RTOS vs Linux）
- Lock-free 与无阻塞数据结构（适用场景、ABA 问题）
- 练习：实现一个 lock-free 单生产者单消费者环形缓冲区并测试延迟

------

## 第9章 中断与 ISR 设计（关键的实时性能点）

- 在 C++ 中编写安全的 ISR：可重入函数、最小工作量、ISR-safe API
- 与对象生命周期的交互（从 ISR 触发任务/信号的最佳实践）
- 将复杂逻辑移出 ISR（Deferred work、task notifications）
- 练习：设计一个 ISR + Deferred Handler 流水线（低延迟与低抖动）

------

## 第10章 高性能数据结构与算法（嵌入式角度）

- 紧凑与缓存友好的数据结构（结构体内存布局、padding elimination）
- 预分配表驱动状态机、跳表、紧凑哈希/开地址哈希
- 查表 vs 计算：什么时候用 LUT，何时用公式
- 练习：优化一个事件分发器（从链表到数组/位掩码实现）

------

## 第11章 模式与范式（嵌入式友好的现代 C++ 设计）

- 静态多态（CRTP）与零开销抽象
- 非虚拟接口 (NVI) 与静态多态替代虚函数
- 策略模式（policy-based design）、可插拔组件
- 责任链、命令、状态机在固件架构中的落地
- 练习：使用 CRTP 重写驱动抽象层并比较开销

------

## 第12章 性能分析与剖析（如何找到真正的瓶颈）

- 仪器化 vs 采样分析（SWO、ITM、SEGGER RTT、gprof、perf）
- 基于周期计数的微基准（`DWT->CYCCNT`、PMU）
- 二进制大小分析（`arm-none-eabi-size`、readelf、objdump）
- 案例：定位一次高延迟问题的完整流程
- 练习：为一个功能写 microbench 并解释结果（避免误导性基准）

------

## 第13章 编译器与优化技巧（深入理解生成代码）

- inline、force_inline、函数边界的成本
- 寄存器使用、栈帧、尾调用优化
- 代码对齐与分支预测友好编写（避免分支错判的微优化）
- 源码到汇编：读懂关键函数的汇编输出并优化
- 练习：对比三种实现（循环展开、递归、手写汇编），分析生成代码

------

## 第14章 能耗优化（面向电池供电设备）

- 省电模式的 API 设计（睡眠/唤醒、外设休眠）
- 代码与硬件配合减少唤醒次数（批量传输、采样策略）
- 编译与链接对能耗的间接影响（代码大小、缓存命中）
- 练习：实现低功耗传感器节点并测量平均电流（理论）估算

------

## 第15章 多种运行时环境：裸机 / RTOS / 嵌入式 Linux

- 各环境下 C++ 的差异与适配（线程模型、库支持、异常与动态内存）
- 在 RTOS 上的线程安全数据结构与优先级设计
- 在嵌入式 Linux 上的性能考虑（用户态/内核态切换、syscall 成本、epoll）
- 练习：把一个模块从裸机移植到 RTOS / Linux 的步骤与坑点

------

## 第16章 网络、序列化与数据处理（边缘计算视角）

- 轻量协议选择（MQTT-SN、CoAP、CBOR、protobuf-lite）
- 内存与零拷贝序列化技巧
- 流式处理与管道化设计（减少内存复制）
- 练习：实现一个零拷贝的消息传输层（SPI/串口 + CBOR）

------

## 第17章 安全、可靠性与测试

- 静态分析工具（clang-tidy、cppcheck）和编译警告策略
- 单元测试（可在主机上运行的硬件抽象层）、集成测试、硬件在环（HIL）
- Fuzzing 和边界测试在嵌入式中的实践
- 防止回归的 CI/CD（交叉构建 + 仿真测试）
- 练习：为关键模块编写单元测试并在 CI 里运行

------

## 第18章 模块化、包管理与版本兼容

- 组件化驱动与接口契约（ABI稳定性）
- 如何在嵌入式中安全使用第三方 C++ 库（裁剪、移植）
- 升级策略（OTA）与回滚设计
- 练习：将一个第三方库裁剪到最小并测量影响

------

## 第19章 案例研究：真实项目深度剖析（3~4 个完整案例）

- 案例 A：低功耗无线传感器节点（裸机 + DMA + sleep）
- 案例 B：基于 RTOS 的实时控制器（低延迟命令路径）
- 案例 C：嵌入式 Linux 上的边缘推理模块（性能/内存折中）
- 每个案例包含：架构、关键代码（C++ 样板）、优化手段、性能数据与教训

------

## 第20章 进阶特性与未来方向

- C++20/23/26 中与嵌入式相关的特性（coroutines 在嵌入式的可行性、模块、ranges）
- ? 为什么/何时采用 coroutine（事件驱动应用的替代设计）
- 硬件加速与异构计算（DSP、NPU）与 C++ 接口设计
- 练习：用 coroutine 改写一段异步 IO 流程（并分析栈/内存开销）

------

## 附录 A：常用设计模板与代码片段（可直接拷贝）

- 固定池、ring-buffer、DMA wrapper、外设 RAII 模板、ISR-safe queue
- CMake Cross-build 模板、链接脚本示例

## 附录 B：调试与测量工具清单（命令与示例）

- GDB/LLDB、OpenOCD、J-Link、SEGGER RTT、perf、valgrind（对 Linux）、QEMU 启动示例

## 附录 C：术语表、性能陷阱清单、常见错误与对策

## 附录 D：建议阅读与参考资料（书籍、博客、标准文档、工具链手册）

# 参考B

## 面向嵌入式的C++教程 - 完整目录

### **第一部分：基础篇 - 嵌入式C++概览**

#### 第1章 嵌入式C++入门

- 1.1 为什么在嵌入式系统中使用C++
- 1.2 C++相比C的优势与代价
- 1.3 嵌入式环境的特殊性：资源受限、实时性、可靠性
- 1.4 C++标准与嵌入式子集（MISRA C++、Embedded C++）
- 1.5 工具链配置：编译器选项与优化级别
- 1.6 第一个嵌入式C++程序：LED闪烁

#### 第2章 内存模型与布局

- 2.1 嵌入式系统的内存架构（Flash、RAM、EEPROM）
- 2.2 C++对象的内存布局
- 2.3 栈与堆的使用策略
- 2.4 静态存储区与常量数据
- 2.5 链接器脚本与内存映射
- 2.6 代码段、数据段分析工具的使用

------

### **第二部分：性能优化核心**

#### 第3章 零开销抽象原则

- 3.1 什么是零开销抽象（Zero-overhead Abstraction）
- 3.2 内联函数与编译器优化
- 3.3 constexpr：编译期计算
- 3.4 编译期多态 vs 运行时多态
- 3.5 模板元编程基础
- 3.6 性能测量：汇编代码分析

#### 第4章 高效的类设计

- 4.1 构造函数优化：初始化列表与成员初始化
- 4.2 移动语义（Move Semantics）在嵌入式中的应用
- 4.3 RVO与NRVO（返回值优化）
- 4.4 空基类优化（EBO）
- 4.5 对象大小与内存对齐
- 4.6 trivial类型与标准布局类型
- 4.7 聚合初始化与designated initializers（C++20）

#### 第5章 模板与泛型编程

- 5.1 函数模板与类模板基础
- 5.2 模板特化与偏特化
- 5.3 SFINAE与编译期类型选择
- 5.4 if constexpr（C++17）：编译期分支
- 5.5 概念（Concepts，C++20）：约束模板参数
- 5.6 模板实例化控制：显式实例化与extern template
- 5.7 零成本策略模式实现

#### 第6章 编译期编程技术

- 6.1 constexpr函数与constexpr变量
- 6.2 consteval：强制编译期求值（C++20）
- 6.3 constinit：静态初始化保证（C++20）
- 6.4 类型萃取（Type Traits）
- 6.5 编译期查找表生成
- 6.6 编译期状态机设计
- 6.7 编译期单位转换与物理量计算

------

### **第三部分：内存管理与资源控制**

#### 第7章 避免动态内存分配

- 7.1 动态内存的代价：碎片化与不确定性
- 7.2 静态存储与栈上分配策略
- 7.3 对象池（Object Pool）模式
- 7.4 定长内存分配器实现
- 7.5 放置new（Placement New）的使用
- 7.6 std::array vs C数组
- 7.7 无堆容器设计

#### 第8章 智能指针与RAII

- 8.1 RAII原则在资源管理中的应用
- 8.2 std::unique_ptr：零开销的独占所有权
- 8.3 std::shared_ptr在嵌入式中的考虑
- 8.4 自定义删除器（Custom Deleter）
- 8.5 引用计数的实现与性能
- 8.6 资源句柄封装：GPIO、外设、文件描述符
- 8.7 作用域守卫（Scope Guard）模式

#### 第9章 容器与数据结构

- 9.1 STL容器的性能分析
- 9.2 std::array：编译期固定大小数组
- 9.3 std::span（C++20）：非拥有型视图
- 9.4 循环缓冲区实现
- 9.5 侵入式容器设计
- 9.6 etl库（Embedded Template Library）介绍
- 9.7 自定义分配器（Allocator）

------

### **第四部分：现代C++特性应用**

#### 第10章 类型安全与强类型

- 10.1 enum class：强类型枚举
- 10.2 类型安全的寄存器访问
- 10.3 std::variant：类型安全的联合体（C++17）
- 10.4 std::optional：可选值语义（C++17）
- 10.5 std::expected：错误处理新范式（C++23）
- 10.6 类型别名与using声明
- 10.7 字面量运算符与自定义单位

#### 第11章 函数式编程元素

- 11.1 Lambda表达式基础
- 11.2 Lambda捕获与性能影响
- 11.3 std::function vs 函数指针
- 11.4 回调机制的零开销实现
- 11.5 std::invoke与可调用对象
- 11.6 函数式错误处理模式
- 11.7 管道操作与范围库（Ranges，C++20）

#### 第12章 并发与同步

- 12.1 原子操作（std::atomic）
- 12.2 内存序（Memory Order）详解
- 12.3 无锁数据结构设计
- 12.4 std::mutex与RAII锁守卫
- 12.5 中断安全的代码编写
- 12.6 临界区保护技术
- 12.7 RTOS任务间通信

#### 第13章 实用语言特性

- 13.1 自动类型推导：auto与decltype
- 13.2 结构化绑定（Structured Binding，C++17）
- 13.3 范围for循环优化
- 13.4 属性（Attributes）：[[nodiscard]]、[[maybe_unused]]等
- 13.5 三路比较运算符（C++20）
- 13.6 指定初始化器（Designated Initializers）
- 13.7 用户定义字面量

------

### **第五部分：硬件交互与系统编程**

#### 第14章 寄存器与外设访问

- 14.1 易失性（volatile）的正确使用
- 14.2 寄存器映射的C++封装
- 14.3 位域（Bit Field）与位操作
- 14.4 类型安全的寄存器类设计
- 14.5 编译期寄存器地址验证
- 14.6 MMIO（内存映射IO）最佳实践
- 14.7 原子位操作

#### 第15章 中断与异常处理

- 15.1 C++中的中断服务例程（ISR）
- 15.2 extern "C"与链接规范
- 15.3 中断向量表配置
- 15.4 C++异常处理的代价
- 15.5 无异常C++编程（-fno-exceptions）
- 15.6 错误码 vs 异常
- 15.7 Result类型模式

#### 第16章 驱动程序开发

- 16.1 HAL层抽象设计
- 16.2 GPIO驱动封装
- 16.3 SPI/I2C/UART通信类
- 16.4 DMA操作的C++接口
- 16.5 定时器与PWM控制
- 16.6 ADC/DAC数据采集
- 16.7 驱动程序的测试策略

------

### **第六部分：设计模式与架构**

#### 第17章 嵌入式设计模式

- 17.1 状态机模式的现代实现
- 17.2 观察者模式与事件系统
- 17.3 策略模式：编译期多态实现
- 17.4 单例模式的线程安全实现
- 17.5 工厂模式与对象创建
- 17.6 命令模式与任务队列
- 17.7 代理模式与硬件抽象

#### 第18章 模块化与接口设计

- 18.1 面向接口编程
- 18.2 依赖注入在嵌入式中的应用
- 18.3 模块化通信协议设计
- 18.4 组件化架构
- 18.5 C++20 Modules初探
- 18.6 头文件组织与编译优化
- 18.7 ABI稳定性考虑

#### 第19章 实时系统编程

- 19.1 确定性执行与时间约束
- 19.2 优先级反转问题
- 19.3 实时调度策略
- 19.4 看门狗定时器使用
- 19.5 时间管理与chrono库
- 19.6 周期性任务实现
- 19.7 抖动（Jitter）控制

------

### **第七部分：调试、测试与工具**

#### 第20章 性能分析与优化

- 20.1 代码大小优化技术
- 20.2 执行速度优化策略
- 20.3 编译器优化选项详解
- 20.4 链接时优化（LTO）
- 20.5 性能分析工具使用
- 20.6 热点代码识别
- 20.7 汇编代码阅读与优化

#### 第21章 调试技术

- 21.1 断言（assert）与静态断言
- 21.2 调试宏与条件编译
- 21.3 JTAG/SWD调试
- 21.4 日志系统设计
- 21.5 printf调试的替代方案
- 21.6 内存越界检测
- 21.7 栈溢出监控

#### 第22章 单元测试与持续集成

- 22.1 嵌入式系统的测试策略
- 22.2 Google Test在嵌入式中的应用
- 22.3 Mock对象与硬件模拟
- 22.4 主机端测试（Host-based Testing）
- 22.5 静态分析工具（Clang-Tidy、Cppcheck）
- 22.6 代码覆盖率分析
- 22.7 CI/CD流程搭建

------

### **第八部分：嵌入式Linux应用开发**

#### 第23章 Linux系统编程基础

- 23.1 文件IO与文件描述符
- 23.2 sysfs与设备文件访问
- 23.3 ioctl系统调用
- 23.4 mmap内存映射
- 23.5 信号处理
- 23.6 进程间通信（IPC）
- 23.7 多线程编程（std::thread）

#### 第24章 Linux设备交互

- 24.1 GPIO通过sysfs/libgpiod操作
- 24.2 I2C设备访问
- 24.3 SPI设备通信
- 24.4 串口编程
- 24.5 网络socket编程
- 24.6 USB设备交互
- 24.7 V4L2视频采集

#### 第25章 系统服务与守护进程

- 25.1 守护进程（Daemon）编写
- 25.2 systemd服务集成
- 25.3 D-Bus通信
- 25.4 日志记录（syslog）
- 25.5 配置文件解析
- 25.6 权限管理与安全
- 25.7 系统资源监控

------

### **第九部分：高级主题**

#### 第26章 协程与异步编程

- 26.1 C++20协程（Coroutines）基础
- 26.2 异步IO模式
- 26.3 生成器（Generator）实现
- 26.4 任务调度器设计
- 26.5 协程在状态机中的应用
- 26.6 协程的性能考虑
- 26.7 async/await模式

#### 第27章 功耗管理

- 27.1 低功耗模式控制
- 27.2 动态电压频率调节（DVFS）
- 27.3 外设电源管理
- 27.4 睡眠模式与唤醒机制
- 27.5 代码优化与功耗关系
- 27.6 电池管理策略
- 27.7 能耗测量方法

#### 第28章 安全编程实践

- 28.1 缓冲区溢出防护
- 28.2 整数溢出检查
- 28.3 安全的字符串操作
- 28.4 加密库集成
- 28.5 安全启动（Secure Boot）
- 28.6 固件更新OTA
- 28.7 代码签名与验证

------

### **第十部分：综合实战项目**

别着急还在想还在想

------

### **附录**

#### 附录A：常用工具链

- A.1 GCC/G++编译器
- A.2 Clang/LLVM
- A.3 CMake构建系统
- A.4 GDB调试器
- A.5 OpenOCD
- A.6 性能分析工具

#### 附录B：标准库参考

- B.1 嵌入式可用的STL组件
- B.2 头文件依赖关系
- B.3 各编译器的支持情况
- B.4 第三方嵌入式库推荐

#### 附录C：编码规范

- C.1 命名约定
- C.2 代码风格
- C.3 注释规范
- C.4 MISRA C++规则精选

#### 附录D：常见问题与解决方案

- D.1 编译错误排查
- D.2 链接问题解决
- D.3 性能瓶颈诊断
- D.4 内存问题调试



