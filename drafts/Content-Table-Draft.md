# 目录草稿

## 第一部分：起手操作

### 第0章 一切的前提

- [x] 前言
- [x] 嵌入式的资源与实时约束（Flash/ROM、RAM、CPU、功耗、启动时间、确定性）
- [x] 急速C语言速通复习
- [x] 传统C++98比C多了什么呢？
- [x] 语言选择原则：何时用 C++、用哪些 C++ 特性（折中与禁用项）
- [x] 性能 vs 可维护性的真实取舍
- [x] 编码规范建议（小型嵌入式友好的 C++ 子集／风格指南）
- [x] 练习：评估三个小示例（用 C、用 C++（面向对象），比较代码大小与性能）

------

### 第1章 工具链与构建（为性能调优打基础）

- [x] 交叉编译基础与 CMake 多目标构建
- [x] 常用编译器选项（-O0/-Og/-O2/-Os/-Ofast、-fno-exceptions、-fno-rtti、-ffunction-sections/ -fdata-sections、-Wl,--gc-sections）
- [x] 链接器
- [x] 链接脚本（Memory、FLASH/RAM 布局、.bss/.data/.rodata）
- [x] 启动代码与初始化顺序（全局构造、构造开销）

------

## **第二部分：性能优化核心**

#### 第2章 零开销抽象原则

- [x] 3.1 什么是零开销抽象（Zero-overhead Abstraction）
- [x] 3.2 内联函数与编译器优化
- [x] 3.3 constexpr：编译期计算
- [x] 3.4 编译期多态 vs 运行时多态

#### 第3章 高效的类设计

- [x] 4.1 构造函数优化：初始化列表与成员初始化
- [x] 4.2 移动语义（Move Semantics）在嵌入式中的应用
- [x] 4.3 RVO与NRVO（返回值优化）
- [x] 4.4 空基类优化（EBO）
- [x] 4.5 对象大小与内存对齐，trivial类型与标准布局类型，聚合初始化与designated initializers（C++20）

#### 第5章 编译期编程技术

- [x] `constexpr`（C++11/14/17/20）与设计技巧：常量表达式计算、lookup tables、编译期字符串处理
- [x] `consteval`、`constinit`（C++20）
- [x] 编译期应用——查找表生成，状态机设计与单位转换与物理量计算
- [x] `if constexpr`

------

## **第三部分：内存管理与资源控制**

#### 第6章 避免动态内存分配

- [x] 7.1 动态内存的代价：碎片化与不确定性（内存布局（静态、堆、栈）、碎片化与内存对齐）
- [x] 7.2 静态存储与栈上分配策略
- [x] 7.3 对象池（Object Pool）模式
- [x] 7.4 固定池 / slab / arena 分配器实现与比较
- [x] 7.5 禁用 heap 或限制 heap 时的替代策略：放置new（Placement New）的使用
- [x] 7.6 std::array vs C数组，你们知道嘛？

#### 第7章 智能指针与RAII

- [x] RAII 在驱动/外设管理中的应用（GPIO、SPI、DMA、文件句柄）
- [x] `unique_ptr`、`shared_ptr` 的嵌入式取舍（内存成本、控制周期）
- [x] intrusive 智能指针与引用计数（非堆实现）
- [x] 8.2 std::unique_ptr：零开销的独占所有权
- [x] 8.3 std::shared_ptr在嵌入式中的考虑
- [x] 8.4 自定义删除器（Custom Deleter）
- [x] 8.5 引用计数的实现与性能
- [ ] 8.6 作用域守卫（Scope Guard）模式

#### 第8章 容器与数据结构

- 9.1 STL容器的性能分析
- 9.2 std::array：编译期固定大小数组
- 9.3 std::span（C++20）：非拥有型视图
- 9.4 循环缓冲区实现
- 9.5 侵入式容器设计
- 9.6 etl库（Embedded Template Library）介绍
- 9.7 自定义分配器（Allocator）

------

## **第四部分：现代C++特性应用**

#### 第9章 类型安全与强类型

- 10.1 enum class：强类型枚举
- 10.2 类型安全的寄存器访问
- 10.3 std::variant：类型安全的联合体（C++17）
- 10.4 std::optional：可选值语义（C++17）
- 10.5 std::expected：错误处理新范式（C++23）
- 10.6 类型别名与using声明
- 10.7 字面量运算符与自定义单位

#### 第10章 函数式编程元素

- 11.1 Lambda表达式基础
- 11.2 Lambda捕获与性能影响
- 11.3 std::function vs 函数指针
- 11.4 回调机制的零开销实现
- 11.5 std::invoke与可调用对象
- 11.6 函数式错误处理模式
- 11.7 管道操作与范围库（Ranges，C++20）

#### 第11章 并发与同步

- 12.1 原子操作（std::atomic）
- 12.2 内存序（Memory Order）详解
- 12.3 无锁数据结构设计
- 12.4 std::mutex与RAII锁守卫
- 12.5 中断安全的代码编写
- 12.6 临界区保护技术
- 12.7 RTOS任务间通信
- C++ 内存模型简介（顺序一致性、释放/获取语义）
- `std::atomic`、原子操作、内存栅栏在嵌入式的使用
- 轻量同步：自旋锁、信号量、条件变量的代价（RTOS vs Linux）
- Lock-free 与无阻塞数据结构（适用场景、ABA 问题）
- 练习：实现一个 lock-free 单生产者单消费者环形缓冲区并测试延迟

#### 第12章 实用语言特性

- 13.1 自动类型推导：auto与decltype
- 13.2 结构化绑定（Structured Binding，C++17）
- 13.3 范围for循环优化
- 13.4 属性（Attributes）：[[nodiscard]]、[[maybe_unused]]等
- 13.5 三路比较运算符（C++20）
- 13.6 指定初始化器（Designated Initializers）
- 13.7 用户定义字面量

------

#### 第13章 异常、RTTI 与错误处理策略（出错了怎么办）

- 为什么在多数嵌入式场景下禁用异常（或限定使用）
- 替代方案：`expected`/`outcome`/错误码、`std::optional`、结果类型封装
- RTTI 的成本与替代（静态多态、CRTP）
- 练习：把一个使用异常的库改造为返回 `Result<T, E>` 的风格

#### 第4章 模板与泛型编程

- 5.1 函数模板与类模板基础
- 5.2 模板特化与偏特化
- 5.3 SFINAE与编译期类型选择
- 5.4 if constexpr（C++17）：编译期分支
- 5.5 概念（Concepts，C++20）：约束模板参数
- 5.6 模板实例化控制：显式实例化与extern template
- 5.7 零成本策略模式实现

------

#### 第15章 高性能数据结构与算法（嵌入式角度）

- 紧凑与缓存友好的数据结构（结构体内存布局、padding elimination）
- 预分配表驱动状态机、跳表、紧凑哈希/开地址哈希
- 查表 vs 计算：什么时候用 LUT，何时用公式
- 练习：优化一个事件分发器（从链表到数组/位掩码实现）

------

#### 第16章 模式与范式（嵌入式友好的现代 C++ 设计）

- 静态多态（CRTP）与零开销抽象
- 非虚拟接口 (NVI) 与静态多态替代虚函数
- 策略模式（policy-based design）、可插拔组件
- 责任链、命令、状态机在固件架构中的落地
- 练习：使用 CRTP 重写驱动抽象层并比较开销

------

#### 第17章 性能分析与剖析（如何找到真正的瓶颈）

- 仪器化 vs 采样分析（SWO、ITM、SEGGER RTT、gprof、perf）
- 基于周期计数的微基准（`DWT->CYCCNT`、PMU）
- 二进制大小分析（`arm-none-eabi-size`、readelf、objdump）
- 案例：定位一次高延迟问题的完整流程
- 练习：为一个功能写 microbench 并解释结果（避免误导性基准）

------

#### 第18章 编译器与优化技巧（深入理解生成代码）

- inline、force_inline、函数边界的成本
- 寄存器使用、栈帧、尾调用优化
- 代码对齐与分支预测友好编写（避免分支错判的微优化）
- 源码到汇编：读懂关键函数的汇编输出并优化
- 练习：对比三种实现（循环展开、递归、手写汇编），分析生成代码



## **第五部分：嵌入式专题：硬件交互与系统编程**

#### 第19章 能耗优化（面向电池供电设备）

- 省电模式的 API 设计（睡眠/唤醒、外设休眠）
- 代码与硬件配合减少唤醒次数（批量传输、采样策略）
- 编译与链接对能耗的间接影响（代码大小、缓存命中）
- 练习：实现低功耗传感器节点并测量平均电流（理论）估算

------

#### 第21章 网络、序列化与数据处理（边缘计算视角）

- 轻量协议选择（MQTT-SN、CoAP、CBOR、protobuf-lite）
- 内存与零拷贝序列化技巧
- 流式处理与管道化设计（减少内存复制）
- 练习：实现一个零拷贝的消息传输层（SPI/串口 + CBOR）

#### 第14章 寄存器与外设访问

- 14.1 易失性（volatile）的正确使用
- 14.2 寄存器映射的C++封装
- 14.3 位域（Bit Field）与位操作
- 14.4 类型安全的寄存器类设计
- 14.5 编译期寄存器地址验证
- 14.6 MMIO（内存映射IO）最佳实践
- 14.7 原子位操作

#### 第15章 中断与异常处理

- 15.1 C++中的中断服务例程（ISR）
  - 在 C++ 中编写安全的 ISR：可重入函数、最小工作量、ISR-safe API
  - 与对象生命周期的交互（从 ISR 触发任务/信号的最佳实践）
  - 将复杂逻辑移出 ISR（Deferred work、task notifications）
  - 练习：设计一个 ISR + Deferred Handler 流水线（低延迟与低抖动）
- 15.2 extern "C"与链接规范
- 15.3 中断向量表配置
- 15.4 C++异常处理的代价
- 15.5 无异常C++编程（-fno-exceptions）
- 15.6 错误码 vs 异常
- 15.7 Result类型模式

#### 第16章 驱动程序开发

- 16.1 HAL层抽象设计
- 16.2 GPIO驱动封装
- 16.3 SPI/I2C/UART通信类
- 16.4 DMA操作的C++接口
- 16.5 定时器与PWM控制
- 16.6 ADC/DAC数据采集
- 16.7 驱动程序的测试策略

------

### **第六部分：设计模式与架构**

#### 第17章 嵌入式设计模式

- 17.1 状态机模式的现代实现
- 17.2 观察者模式与事件系统
- 17.3 策略模式：编译期多态实现
- 17.4 单例模式的线程安全实现
- 17.5 工厂模式与对象创建
- 17.6 命令模式与任务队列
- 17.7 代理模式与硬件抽象

#### 第18章 模块化与接口设计

- 18.1 面向接口编程
- 18.2 依赖注入在嵌入式中的应用
- 18.3 模块化通信协议设计
- 18.4 组件化架构
- 18.5 C++20 Modules初探
- 18.6 头文件组织与编译优化
- 18.7 ABI稳定性考虑

#### 第19章 实时系统编程

- 19.1 确定性执行与时间约束
- 19.2 优先级反转问题
- 19.3 实时调度策略
- 19.4 看门狗定时器使用
- 19.5 时间管理与chrono库
- 19.6 周期性任务实现
- 19.7 抖动（Jitter）控制

------

### **第七部分：调试、测试与工具**

#### 第20章 性能分析与优化

- 20.1 代码大小优化技术
- 20.2 执行速度优化策略
- 20.3 编译器优化选项详解
- 20.4 链接时优化（LTO）
- 20.5 性能分析工具使用
- 20.6 热点代码识别
- 20.7 汇编代码阅读与优化

#### 第21章 调试技术

- 21.1 断言（assert）与静态断言
- 21.2 调试宏与条件编译
- 21.3 JTAG/SWD调试
- 21.4 日志系统设计
- 21.5 printf调试的替代方案
- 21.6 内存越界检测
- 21.7 栈溢出监控

#### 第22章 单元测试与持续集成

- 22.1 嵌入式系统的测试策略
- 22.2 Google Test在嵌入式中的应用
- 22.3 Mock对象与硬件模拟
- 22.4 主机端测试（Host-based Testing）
- 22.5 静态分析工具（Clang-Tidy、Cppcheck）
- 22.6 代码覆盖率分析
- 22.7 CI/CD流程搭建

------

### **第八部分：嵌入式Linux应用开发**

#### 第23章 Linux系统编程基础

- 23.1 文件IO与文件描述符
- 23.2 sysfs与设备文件访问
- 23.3 ioctl系统调用
- 23.4 mmap内存映射
- 23.5 信号处理
- 23.6 进程间通信（IPC）
- 23.7 多线程编程（std::thread）

#### 第24章 Linux设备交互

- 24.1 GPIO通过sysfs/libgpiod操作
- 24.2 I2C设备访问
- 24.3 SPI设备通信
- 24.4 串口编程
- 24.5 网络socket编程
- 24.6 USB设备交互
- 24.7 V4L2视频采集

#### 第25章 系统服务与守护进程

- 25.1 守护进程（Daemon）编写
- 25.2 systemd服务集成
- 25.3 D-Bus通信
- 25.4 日志记录（syslog）
- 25.5 配置文件解析
- 25.6 权限管理与安全
- 25.7 系统资源监控

------

### **第九部分：高级主题**

#### 第26章 协程与异步编程

- 26.1 C++20协程（Coroutines）基础
- 26.2 异步IO模式
- 26.3 生成器（Generator）实现
- 26.4 任务调度器设计
- 26.5 协程在状态机中的应用
- 26.6 协程的性能考虑
- 26.7 async/await模式

#### 第27章 功耗管理

- 27.1 低功耗模式控制
- 27.2 动态电压频率调节（DVFS）
- 27.3 外设电源管理
- 27.4 睡眠模式与唤醒机制
- 27.5 代码优化与功耗关系
- 27.6 电池管理策略
- 27.7 能耗测量方法

#### 第28章 安全编程实践

- 28.1 缓冲区溢出防护
- 28.2 整数溢出检查
- 28.3 安全的字符串操作
- 28.4 加密库集成
- 28.5 安全启动（Secure Boot）
- 28.6 固件更新OTA
- 28.7 代码签名与验证

------

## 附录 A：常用设计模板与代码片段（可直接拷贝）

- 固定池、ring-buffer、DMA wrapper、外设 RAII 模板、ISR-safe queue
- CMake Cross-build 模板、链接脚本示例

## 附录 B：调试与测量工具清单（命令与示例）

- GDB/LLDB、OpenOCD、J-Link、SEGGER RTT、perf、valgrind（对 Linux）、QEMU 启动示例

## 附录 C：术语表、性能陷阱清单、常见错误与对策

## 附录 D：建议阅读与参考资料（书籍、博客、标准文档、工具链手册

#### 附录A：常用工具链

- A.1 GCC/G++编译器
- A.2 Clang/LLVM
- A.3 CMake构建系统
- A.4 GDB调试器
- A.5 OpenOCD
- A.6 性能分析工具

#### 附录B：标准库参考

- B.1 嵌入式可用的STL组件
- B.2 头文件依赖关系
- B.3 各编译器的支持情况
- B.4 第三方嵌入式库推荐

#### 附录C：编码规范

- C.1 命名约定
- C.2 代码风格
- C.3 注释规范
- C.4 MISRA C++规则精选

#### 附录D：常见问题与解决方案

- D.1 编译错误排查
- D.2 链接问题解决
- D.3 性能瓶颈诊断
- D.4 内存问题调试





------

# 第一部分：基础篇 — 嵌入式 C++ 概览与设计思维

## 第1章 设计与约束 —— 嵌入式系统中写 C++ 的思维模型

- 嵌入式的资源与实时约束（Flash/ROM、RAM、CPU、功耗、启动时间、确定性）
- 嵌入式环境的特殊性：资源受限、实时性、可靠性
- 语言选择原则：何时用 C++、用哪些 C++ 特性（折中与禁用项）
- 性能 vs 可维护性的真实取舍
- 编码规范建议（小型嵌入式友好的 C++ 子集／风格指南 / MISRA C++ 精选）
- 练习：评估三个小示例（用 C、用 C++（面向对象），比较代码大小与性能）
- 章末速查：适用/禁用的 C++ 特性清单

## 第2章 嵌入式 C++ 入门与第一个工程

- 第一个嵌入式C++程序：LED 闪烁示例（裸机/RTOS/Linux 三种实现）
- extern "C" 与链接规范
- 工具链配置简介（交叉编译基础）

## 第3章 内存模型与布局 / 链接器脚本

- 嵌入式系统的内存架构（Flash、RAM、EEPROM）
- C++ 对象的内存布局
- 栈与堆的使用策略
- 静态存储区与常量数据
- 链接器脚本（Memory、FLASH/RAM 布局、.bss/.data/.rodata）
- 代码段、数据段分析工具的使用（readelf、objdump、arm-none-eabi-size）

------

# 第二部分：工具链、构建与编译期技术（为性能调优打基础）

## 第4章 工具链与构建（为性能调优打基础）

- 交叉编译基础与 CMake 多目标构建
- 常用编译器选项（-O0/-Og/-O2/-Os/-Ofast、-fno-exceptions、-fno-rtti、-ffunction-sections/ -fdata-sections、-Wl,--gc-sections）
- 链接器与 LTO/ThinLTO，影响代码大小与性能的链接策略
- 链接脚本示例（Memory map）与初始化顺序说明
- 启动代码与初始化顺序（全局构造、构造开销、constinit/consteval 问题）
- 练习：建立最小 cross-build pipeline + 分析二进制节大小

## 第5章 编译期技术 —— 把工作尽量移到编译时

- `constexpr`（C++11/14/17/20）与设计技巧：常量表达式计算、lookup tables、编译期字符串处理
- `consteval`、`constinit`（C++20）
- 模板元编程（TMP）基础与实用模式（编译期映射、选择实现）
- `static_assert`、SFINAE、`if constexpr`
- 类型萃取（Type Traits）与概念（Concepts，C++20）
- 编译期查找表/CRC 表/小型 FSM 的实现练习（运行时 vs 编译期比较）

------

# 第三部分：类型、容器与内存管理（嵌入式的内存控制武器库）

## 第6章 现代类型与轻量容器

- `std::span`、`std::string_view`、`string_ref` 的使用场景与零拷贝设计
- `std::array`、`std::optional`、`std::variant` 在嵌入式的适用性与成本
- small-buffer-optimization 思路（small-vector）、small_vector 实现练习
- `std::pmr` / 自定义分配器（内嵌池、紧凑分配）——何时使用，何时避免
- STL 容器在嵌入式中的性能分析与替代（ETL 等）
- 练习：实现一个固定容量的 `small_vector<T>` 并在 ISR/线程间测试

## 第7章 容器与数据结构 — 高性能设计

- 紧凑与缓存友好的数据结构（结构体内存布局、padding elimination）
- 循环缓冲区（ring-buffer）实现与分析
- 侵入式容器设计
- 紧凑哈希/开地址哈希、表驱动状态机
- 练习：优化一个事件分发器（从链表到数组/位掩码实现）

## 第8章 内存管理与性能（嵌入式黄金法则）

- 内存布局（静态、堆、栈）、碎片化与内存对齐
- 固定池 / slab / arena 分配器实现与比较
- 禁用 heap 或限制 heap 时的替代策略：对象池、栈分配、placement new
- 避免动态分配的 API 设计模式
- 练习：实现并 benchmark 一个固定大小对象池（含多线程安全版本）

------

# 第四部分：所有权、资源管理与错误处理

## 第9章 所有权与资源管理 —— RAII 实战

- RAII 在驱动/外设管理中的应用（GPIO、SPI、DMA、文件句柄）
- `unique_ptr`、`shared_ptr` 的嵌入式取舍（内存成本、控制周期）
- intrusive 智能指针与引用计数（非堆实现）
- 自定义删除器（Custom Deleter）与 Scope Guard 模式
- 练习：用 RAII 封装外设初始化/关闭流程（支持异常与无异常两套策略）

## 第10章 异常、RTTI 与错误处理策略

- 为什么在多数嵌入式场景下禁用异常（或限定使用）
- RTTI 的成本与替代（静态多态、CRTP）
- 替代方案：`expected`/`outcome`/错误码、`std::optional`、结果类型封装、Result 模式
- 练习：把一个使用异常的库改造为返回 `Result<T, E>` 的风格

------

# 第五部分：并发、同步与实时性

## 第11章 并发、原子与内存模型（从裸机到 Linux）

- C++ 内存模型简介（顺序一致性、释放/获取语义）
- `std::atomic`、原子操作、内存栅栏在嵌入式的使用
- 内存序（Memory Order）详解
- Lock-free 与无阻塞数据结构（适用场景、ABA 问题）
- 练习：实现一个 lock-free 单生产者单消费者环形缓冲区并测试延迟

## 第12章 线程、RTOS 与任务间通信

- 轻量同步：自旋锁、信号量、条件变量的代价（RTOS vs Linux）
- RTOS 任务间通信与优先级设计
- 中断安全的数据结构与优先级反转、看门狗使用
- 练习：RTOS 下线程安全数据结构实现

------

# 第六部分：中断、ISR 与硬件交互

## 第13章 中断与 ISR 设计（关键的实时性能点）

- 在 C++ 中编写安全的 ISR：可重入函数、最小工作量、ISR-safe API
- ISR 与对象生命周期的交互（从 ISR 触发任务/信号的最佳实践）
- 将复杂逻辑移出 ISR（Deferred work、task notifications）
- 练习：设计一个 ISR + Deferred Handler 流水线（低延迟与低抖动）

## 第14章 寄存器与外设访问 / 驱动程序开发

- 易失性（volatile）的正确使用
- 寄存器映射的 C++ 封装、位域与类型安全寄存器类设计
- MMIO（内存映射 IO）最佳实践与编译期地址验证
- HAL 层抽象设计、GPIO/SPI/I2C/UART 等驱动封装
- DMA 操作的 C++ 接口、定时器与 PWM、ADC/DAC 数据采集
- 驱动程序的测试策略

------

# 第七部分：语言特性、模式与架构

## 第15章 静态多态、设计模式与零开销抽象

- 静态多态（CRTP）与零开销抽象
- 非虚拟接口 (NVI) 与静态多态替代虚函数
- 策略模式（policy-based design）、可插拔组件
- 空基类优化（EBO）、trivial/standard layout 类型
- 练习：使用 CRTP 重写驱动抽象层并比较开销

## 第16章 常用设计模式与模块化

- 状态机、观察者、策略、单例（线程安全）、工厂、命令、代理等模式的嵌入式实现
- 面向接口编程、依赖注入在嵌入式中的应用
- 模块化通信协议设计、组件化架构
- C++20 Modules 初探、头文件组织与编译优化
- ABI 稳定性考虑

## 第17章 实时系统编程（更深）

- 确定性执行与时间约束、调度策略
- 优先级反转问题与应对技术
- 时间管理与 chrono 库、周期性任务实现与 jitter 控制
- 练习：实时系统调度与抖动测量

------

# 第八部分：性能分析、编译器与优化（源码到汇编）

## 第18章 性能分析与剖析（如何找到真正的瓶颈）

- 仪器化 vs 采样分析（SWO、ITM、SEGGER RTT、gprof、perf）
- 基于周期计数的微基准（DWT->CYCCNT、PMU）
- 二进制大小分析（arm-none-eabi-size、readelf、objdump）
- 案例：定位一次高延迟问题的完整流程
- 练习：为一个功能写 microbench 并解释结果（避免误导性基准）

## 第19章 编译器与优化技巧（深入理解生成代码）

- inline、force_inline、函数边界的成本
- 寄存器使用、栈帧、尾调用优化
- 代码对齐与分支预测友好编写（避免分支错判的微优化）
- 源码到汇编：读懂关键函数的汇编输出并优化
- 练习：对比三种实现（循环展开、递归、手写汇编），分析生成代码

------

# 第九部分：功耗、网络与数据处理

## 第20章 能耗优化（面向电池供电设备）

- 省电模式的 API 设计（睡眠/唤醒、外设休眠）
- 代码与硬件配合减少唤醒次数（批量传输、采样策略）
- 编译与链接对能耗的间接影响（代码大小、缓存命中）
- 练习：实现低功耗传感器节点并测量平均电流（理论估算）

## 第21章 网络、序列化与边缘数据处理

- 轻量协议选择（MQTT-SN、CoAP、CBOR、protobuf-lite）
- 内存与零拷贝序列化技巧
- 流式处理与管道化设计（减少内存复制）
- 练习：实现一个零拷贝的消息传输层（SPI/串口 + CBOR）

------

# 第十部分：安全、可靠性、测试与 CI

## 第22章 安全编程实践

- 缓冲区溢出 / 整数溢出防护
- 安全的字符串操作与加密库集成
- 安全启动（Secure Boot）、固件更新 OTA、代码签名与验证

## 第23章 测试、静态分析与持续集成

- 静态分析工具（clang-tidy、cppcheck）和编译警告策略
- 单元测试（主机端测试 / Google Test）、Mock 对象与硬件模拟
- 集成测试、硬件在环（HIL）、Fuzzing 与边界测试
- 防止回归的 CI/CD（交叉构建 + 仿真测试）
- 练习：为关键模块编写单元测试并在 CI 里运行

------

# 第十一部分：嵌入式 Linux 专题

## 第24章 Linux 系统编程基础

- 文件 IO 与文件描述符、sysfs 与设备文件访问
- ioctl、mmap、信号处理、进程间通信（IPC）
- 多线程编程（std::thread）与用户态/内核态成本

## 第25章 Linux 设备交互与系统服务

- GPIO 通过 sysfs/libgpiod 操作、I2C/SPI 串口编程、网络 socket
- USB、V4L2 视频采集
- 守护进程（Daemon）编写、systemd 服务集成、D-Bus、syslog
- 权限管理与系统资源监控

------

# 第十二部分：协程、异步与高级主题

## 第26章 协程与异步编程

- C++20 协程（Coroutines）基础
- 异步 IO 模式、生成器（Generator）实现
- 任务调度器设计、协程在状态机中的应用
- 协程的性能考虑、async/await 模式
- 练习：用 coroutine 改写一段异步 IO 流程并分析栈/内存开销

## 第27章 功耗管理（深入）

- 低功耗模式控制、DVFS、外设电源管理
- 睡眠模式与唤醒机制、能耗测量方法
- 电池管理策略

## 第28章 高级安全与可靠性

- 代码签名、固件回滚设计、OTA 升级策略
- 故障恢复与可靠性工程

------

# 第十三部分：综合案例研究与实战项目

在想了在想了

------

# 附录

## 附录 A：常用设计模板与代码片段（可直接拷贝）

- 固定池、ring-buffer、DMA wrapper、外设 RAII 模板、ISR-safe queue
- CMake Cross-build 模板、链接脚本示例

## 附录 B：调试与测量工具清单（命令与示例）

- GDB/LLDB、OpenOCD、J-Link、SEGGER RTT、perf、valgrind（对 Linux）、QEMU 启动示例、SWO/ITM 使用

## 附录 C：标准库与第三方库参考

- 嵌入式可用的 STL 组件、ETL、各编译器支持情况、裁剪策略

## 附录 D：编码规范与术语表

- 命名约定、代码风格、注释规范、MISRA C++ 规则精选
- 性能陷阱清单、常见错误与对策

## 附录 E：参考阅读与资源（书籍、博客、标准文档、工具链手册）

