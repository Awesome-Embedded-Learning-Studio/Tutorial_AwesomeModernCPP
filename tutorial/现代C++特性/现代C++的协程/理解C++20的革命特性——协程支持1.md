# ç†è§£C++20çš„é©å‘½ç‰¹æ€§â€”â€”åç¨‹æ”¯æŒ1

## ä»€ä¹ˆæ˜¯åç¨‹ï¼Ÿ

â€‹	é¦–å…ˆï¼Œå¼•å‡ºåç¨‹ï¼Œæˆ‘ä»¬è·‘ä¸äº†æåˆ°å‡½æ•°çš„è¿è¡Œæ—¶æ ˆï¼šè°ƒç”¨ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œè¿è¡Œæ—¶ä¼šä¸ºè¯¥å‡½æ•°åˆ†é…ä¸€ä¸ª**æ ˆå¸§**ï¼Œåœ¨æ ˆå¸§ä¸­ä¿å­˜å‚æ•°ã€è¿”å›åœ°å€ä»¥åŠå‡½æ•°ä¸­å£°æ˜çš„å±€éƒ¨å˜é‡â€”â€”è¿™å°±æ˜¯å‡½æ•°çš„è¿è¡Œæ—¶ç¯å¢ƒã€‚

â€‹	åç¨‹çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**å‡½æ•°å¯ä»¥åœ¨æ‰§è¡Œåˆ°ä¸€åŠæ—¶æŒ‚èµ·ï¼ˆsuspendï¼‰ï¼ŒæŠŠæ‰§è¡Œæƒè®©å‡º`(yield)`ï¼›å½“æ¡ä»¶æ»¡è¶³æ—¶å†æ¢å¤ï¼ˆ`resume`ï¼‰å¹¶ä»åŸå¤„ç»§ç»­æ‰§è¡Œã€‚**è¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨ç”¨æˆ·æ€å®ç°è½»é‡çº§çš„åä½œå¼è°ƒåº¦ï¼šä¸åŒä»»åŠ¡æŒ‰ç¨‹åºæ§åˆ¶æœ‰åºåˆ‡æ¢ï¼Œè€Œä¸æ˜¯ä¾èµ–æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„æŠ¢å å¼è°ƒåº¦ã€‚

â€‹	å½“ç„¶ï¼Œæˆ‘ä»¬éœ€è¦è¯´æ˜æ˜¯â€”â€”æŒ‰ç…§å®ç°æ–¹å¼ï¼Œ

â€‹	åç¨‹æœ‰ä¸¤ç±»å®ç°æ€è·¯ï¼š**æœ‰æ ˆåç¨‹ï¼ˆstackfulï¼‰**ä¼šåˆ‡æ¢å®Œæ•´çš„æ‰§è¡Œæ ˆï¼›è€Œ**C++20 çš„åç¨‹å±äºâ€œæ— æ ˆï¼ˆ`stackless`ï¼‰â€èŒƒå¼**â€”â€”ç¼–è¯‘å™¨ä¼šæŠŠåœ¨æŒ‚èµ·ç‚¹éœ€è¦ä¿ç•™çš„å±€éƒ¨å˜é‡å’ŒçŠ¶æ€å°è£…åˆ°ä¸€ä¸ª **åç¨‹å¸§ï¼ˆcoroutine frameï¼‰**ä¸­ã€‚æŒ‚èµ·æ—¶ä¿å­˜è¯¥åç¨‹å¸§å¹¶è¿”å›ï¼Œæ¢å¤æ—¶ä»å¸§é‡Œæ¢å¤çŠ¶æ€ç»§ç»­æ‰§è¡Œã€‚å› ä¸ºä¸éœ€è¦åˆ‡æ¢æ“ä½œç³»ç»Ÿæ ˆï¼Œä¹Ÿé€šå¸¸ä¸éœ€è¦é¢‘ç¹è¿›å…¥å†…æ ¸æ€ï¼Œå¯¹äºæç«¯çš„å¹¶å‘åœºæ™¯ï¼Œè¿™ç©æ„æ˜¾ç„¶æ¯”è¿›ç¨‹/çº¿ç¨‹çš„åˆ‡æ¢è¦å¼ºçš„å¤ªå¤šå¤ªå¤šã€‚

æˆ‘ä»¬ä½¿ç”¨åç¨‹é€šå¸¸æœ‰ä¸‰å¤§ç†ç”±ï¼š

- **æŠŠå¼‚æ­¥ä»£ç å†™æˆåŒæ­¥é£æ ¼**ï¼šå¤æ‚çš„å›è°ƒé“¾å¯ä»¥è¢«çº¿æ€§ã€é¡ºåºçš„ä»£ç æ›¿ä»£ï¼Œé€»è¾‘æ›´ç›´è§‚ã€æ˜“è¯»ã€‚
- **é«˜å¹¶å‘ã€ä½å¼€é”€**ï¼šç›¸æ¯”çº¿ç¨‹ï¼Œåç¨‹çš„åˆ›å»ºä¸åˆ‡æ¢ä»£ä»·æ›´ä½ï¼Œé€‚åˆå¤§é‡ I/O å¯†é›†å‹å¹¶å‘ä»»åŠ¡ã€‚
- **æ›´çµæ´»çš„æ§åˆ¶æµè¡¨è¾¾**ï¼šåç¨‹å¤©ç”Ÿé€‚åˆå®ç°ç”Ÿæˆå™¨ã€æµæ°´çº¿ã€æƒ°æ€§è®¡ç®—ä¸å¼‚æ­¥ä»»åŠ¡é“¾ç­‰æ¨¡å¼ã€‚

## C++çš„åç¨‹æ”¯æŒæ˜¯å¦‚ä½•çš„ï¼Ÿ

â€‹	æˆ‘ä»¬è¿™é‡Œæ˜¯C++çš„åšå®¢ï¼Œé¿å…ä¸äº†è®¨è®ºC++çš„åç¨‹æ”¯æŒã€‚ä½†å¾ˆé—æ†¾ï¼Œç¬”è€…å¿…é¡»å¼ºè°ƒçš„æ˜¯â€”â€”C++20çš„åç¨‹æ¥å£æ˜¯åœ¨æ¯”è¾ƒéš¾å†™ã€‚ç¬”è€…é€›äº†äº›è®ºå›ï¼ŒåŒ…æ‹¬çœ‹åˆ°å…¶ä»–åŒå¿—å¯¹C++20çš„åç¨‹çš„ä»‹ç»ï¼Œä¸å¾—ä¸æ‰¿è®¤â€”â€”è¿™ä¸€å¥—æ¥å£å¦‚æœæˆ‘ä»¬ä¸ç†è§£åç¨‹ï¼Œå®åœ¨æ˜¯éš¾ä»¥ç†è§£ï¼ˆä¸ºæ­¤æˆ‘æŒ£æ‰äº†å¥½ä¸€ä¼šï¼‰ã€‚å› æ­¤ï¼Œç¬”è€…éå¸¸å»ºè®®å„ä½çœ‹æ­¤åšå®¢çš„æ—¶å€™ï¼Œå¤šç»ƒä¹ ä»£ç ï¼Œæ‰“ä¸€æ‰“æ—¥å¿—ã€‚è¿™æ ·æœ‰åŠ©äºä½ ç†è§£â€”â€”C++çš„åç¨‹åˆ°åº•åœ¨åšä»€ä¹ˆã€‚

â€‹	ä¸ºäº†å±•å¼€è¯´æ˜ä¸Šé¢çš„å†…å®¹ï¼Œç¬”è€…å†³å®šé‡æ–°æ•´ç†ä¸€ä¸‹`cppreference`å¯¹äºåç¨‹çš„ä»‹ç»

> æˆ‘çŸ¥é“æœ‰ä¸€äº›æœ‹å‹è¿˜æ²¡çœ‹ä»€ä¹ˆæ˜¯C++ä¸­çš„åç¨‹ï¼Œæ‚¨å¯ä»¥è‡ªè¡Œå…ˆçœ‹çœ‹`cppreference`å¯¹è¿™ä¸ªæ¥å£çš„è®²è¿°ï¼Œç¬”è€…ç¬¬ä¸€æ¬¡çœ‹åˆ°ä¸€åŠå°±å…³æ‰å†™åˆ«çš„å»äº†ï¼Œå®åœ¨æœ‰äº›éš¾æ‡‚ï¼ğŸ‘‰[åç¨‹ (C++20) - cppreference.cn - C++å‚è€ƒæ‰‹å†Œ](https://cppreference.cn/w/cpp/language/coroutines)

â€‹	æ•´ç†ä¸‹æ¥â€”â€”æˆ‘ä»¬éœ€è¦äº†è§£è¿™äº›å†…å®¹ï¼Œæ‚¨è®°åœ¨æ‰‹å¤´åšä¸€ä¸ªç¬”è®°ã€‚æˆ–è€…ä½ ä¸æƒ³çœ‹çš„è¯ï¼Œå¯ä»¥è·³åˆ°ä¸‹ä¸€éƒ¨åˆ†çœ‹ä¸€ä¸‹ä¾‹å­ï¼Œä½ æ‰«ä¸€çœ¼å°±çŸ¥é“å¤§æ¦‚æˆ‘ä»¬éœ€è¦å¦‚ä½•ä½¿ç”¨C++20æ”¯æŒçš„åç¨‹äº†

- ç¼–è¯‘å™¨æä¾›çš„ä¸‰ä¸ªæ‰©å±•å…³é”®å­—éœ€è¦æˆ‘ä»¬å…ˆçŸ¥é“ï¼š

  - `co_await`ï¼šè¿™ä¸ªå…³é”®å­—ç”¨äºæŠŠåç¨‹æŒ‚èµ·æ¥ï¼Œç›´åˆ°æˆ‘ä»¬**è°ƒç”¨äº†æ¢å¤æœºåˆ¶æŠŠå®ƒæ”¾ä¸‹æ¥ï¼**ï¼Œéœ€è¦è¯´æ˜çš„æ˜¯â€”â€”å’±ä»¬çš„`co_await`çš„åé¢éœ€è¦è·Ÿä¸€ä¸ªè¡¨è¾¾å¼ã€‚è¿™ä¸ªè¡¨è¾¾å¼å¾€å¾€æ˜¯**ä¸€ä¸ªæ”¯æŒè‹¥å¹²C++çº¦å®šåç¨‹æ¥å£çš„å¯¹è±¡**ï¼ˆè‡³å°‘ç¬”è€…ç›®å‰è¿™æ ·ä½¿ç”¨ï¼Œå„ä½C++åç¨‹å¤§è·ŒèŠ±æ‹›å¾ˆå¤šï¼Œçœ‹ç€å®åœ¨è´¹è§£éš¾æ‡‚ï¼Œæ‰€ä»¥ç´¢æ€§å…ˆè¿™æ ·è¯´ï¼Œä¾¿äºåˆçº§è¯»è€…çš„ç†è§£ï¼‰ã€‚äººè¯å°±æ˜¯ï¼Œç­‰å¾…çš„ä¸œè¥¿ä¸­è¦å®ç°ç»™å®šç­¾åçš„å‡½æ•°ï¼Œä¸å®ç°ç¼–è¯‘å™¨å°±ä¼šå‘Šè¯‰ä½ æ¥å£ç¼ºå¤±ï¼
  - `co_yield`ï¼šç”¨äºæš‚åœæ‰§è¡Œå¹¶è¿”å›ä¸€ä¸ªå€¼ã€‚å•¥æ„æ€å‘¢ï¼Œè¿™ä¸ªæ—¶å€™æ”¾åœ¨å’±ä»¬çš„åç¨‹å‡½æ•°é‡Œï¼Œä»–å°±ä¼šè¿”å›co_yieldä¿®é¥°çš„è¡¨è¾¾å¼å­çš„å€¼ï¼Œè¿™ä¸ªå€¼éœ€è¦åˆ©ç”¨ä¸€ä¸ªæ¥å£è¿”å›å›å»ã€‚å…·ä½“æ€ä¹ˆç”¨åˆ«ç€æ€¥ï¼Œæˆ‘ä»¬åé¢ä¼šè®²
  - `co_return`ï¼šç”¨äºå®Œæˆæ‰§è¡Œå¹¶è¿”å›ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å†™ä¸‹ä¸€ä¸ª`co_return`ï¼Œè¿™ä¸ªåç¨‹å‡½æ•°å°±ç»“æŸäº†ï¼Œå‡†å¤‡é”€æ¯æˆ‘ä»¬çš„åç¨‹ç»“æ„ä½“ã€‚

- è¿˜æœ‰ä¸€éƒ¨åˆ†æ˜¯ä¸€ä¸ªåç¨‹å‡½æ•°éœ€è¦è¿”å›çš„ä¸€ä¸ªç»“æ„ä½“ï¼ˆ**åç¨‹è¿”å›ç±»å‹**ï¼‰ï¼Œè¿™ä¸ªç»“æ„ä½“è¢«ç”¨æ¥ç»™åç¨‹æ¡†æ¶æä¾›ä¸€å®šçš„è°ƒåº¦ä¿¡æ¯ã€‚å®é™…ä¸Šï¼Œå’±ä»¬çš„ç°ä»£C++éƒ½æ˜¯ä½¿ç”¨çš„æ¥å£æ¥è¡¨ç¤ºèƒ½ä¸èƒ½æ”¯æŒåç¨‹ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦åšçš„æ˜¯å£°æ˜ä¸€ä¸ªå¯¹è±¡ç±»å‹ï¼Œ**ä»–å¿…é¡»å†…åµŒ`promise_type`,æ³¨æ„å°±æ˜¯è¿™ä¸ªåç§°ï¼Œå˜ä¸äº†ï¼**

  > ```cpp
  > // coroutineä¸­
  > #if __cpp_concepts
  >     requires requires { typename _Result::promise_type; }
  >     struct __coroutine_traits_impl<_Result, void>
  > #else
  >     struct __coroutine_traits_impl<_Result,
  > 				   __void_t<typename _Result::promise_type>>
  > #endif
  >     {
  >       using promise_type = typename _Result::promise_type;
  >     };
  > ```

  ä¸‹ä¸€æ­¥ï¼Œå°±æ˜¯å£°æ˜å’Œå®ç°è¿™ä¸ª`promise_type`ä¸­å¿…é¡»è¦å­˜åœ¨çš„æ¥å£ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬è¦å®ç°çš„â€”â€”

  | æ¥å£ (å‡½æ•°)                                 | ä½œç”¨                                                         | è¿”å›ç±»å‹è¦æ±‚                                                 |
  | ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **1. `get_return_object()`**                | **è·å–è¿”å›å¯¹è±¡**ï¼šåç¨‹å‡½æ•°è¢«è°ƒç”¨æ—¶ç¬¬ä¸€ä¸ªæ‰§è¡Œçš„å‡½æ•°ã€‚å®ƒè´Ÿè´£åˆ›å»ºå¹¶è¿”å›è°ƒç”¨è€…ï¼ˆå¤–éƒ¨ä¸–ç•Œï¼‰ç”¨äºæ“ä½œåç¨‹çš„**è¿”å›å¯¹è±¡**ï¼ˆå¦‚æ‚¨çš„ `Generator`ï¼‰ã€‚ | å¿…é¡»è¿”å›åç¨‹å‡½æ•°çš„è¿”å›ç±»å‹ï¼ˆæˆ–å¯è½¬æ¢ä¸ºè¯¥ç±»å‹ï¼‰ã€‚             |
  | **2. `initial_suspend()`**                  | **åˆå§‹æš‚åœç‚¹**ï¼šå†³å®šåç¨‹åœ¨åˆ›å»ºæ—¶æ˜¯**ç«‹å³æ‰§è¡Œ**è¿˜æ˜¯**æš‚åœ**ã€‚ | å¿…é¡»è¿”å›ä¸€ä¸ª **Awaitable** å¯¹è±¡ï¼ˆå¦‚ `std::suspend_always` æˆ– `std::suspend_never`ï¼‰ã€‚ |
  | **3. `final_suspend()`**                    | **æœ€ç»ˆæš‚åœç‚¹**ï¼šå†³å®šåç¨‹åœ¨æ‰§è¡Œå®Œæ¯•ï¼ˆ`co_return` æˆ–å‡½æ•°ä½“ç»“æŸï¼‰åæ˜¯**ç«‹å³é”€æ¯**è¿˜æ˜¯**æš‚åœ**ã€‚ | å¿…é¡»è¿”å›ä¸€ä¸ª **Awaitable** å¯¹è±¡ã€‚                            |
  | **4. `return_void()` æˆ– `return_value(V)`** | **è¿”å›å€¼å¤„ç†**ï¼šç”¨äºå¤„ç†åç¨‹çš„**ç»ˆç»“å€¼**æˆ–**ç»ˆç»“çŠ¶æ€**ã€‚     | å¦‚æœåç¨‹å‡½æ•°è¿”å› `void` (ä¾‹å¦‚ `Generator` ç»å¸¸å¦‚æ­¤)ï¼Œå¿…é¡»æä¾› `return_void()`ã€‚å¦‚æœåç¨‹ä½¿ç”¨ `co_return V;` è¿”å›ä¸€ä¸ªå€¼ï¼Œåˆ™å¿…é¡»æä¾› `return_value(V)`ã€‚ä¸¤è€…**äºŒé€‰ä¸€**ã€‚ |
  | **5. `unhandled_exception()`**              | **å¼‚å¸¸å¤„ç†**ï¼šå½“åç¨‹å†…éƒ¨å‘ç”Ÿ**æœªæ•è·çš„å¼‚å¸¸**æ—¶è¢«è°ƒç”¨ã€‚       | å¿…é¡»è¿”å› `void`ã€‚                                            |

  å½“ç„¶ï¼Œè¿˜è¦å€¼å¾—ä¸€æçš„æ˜¯ï¼Œå¦‚æœä½ çš„åç¨‹å‡½æ•°ä¸­ï¼Œç”¨åˆ°äº†`co_yield`å…³é”®å­—ï¼Œä½ è¿˜éœ€è¦é¢å¤–çš„æå®šä¸€ä¸ªå‡½æ•°

  | æ¥å£ (å‡½æ•°)                | ä½œç”¨                                                         | è¿”å›ç±»å‹è¦æ±‚                                                 |
  | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **`yield_value(T value)`** | **äº§å‡ºå€¼**ï¼šå½“åç¨‹æ‰§è¡Œåˆ° `co_yield T;` æ—¶è¢«è°ƒç”¨ã€‚å®ƒè´Ÿè´£å­˜å‚¨äº§å‡ºçš„å€¼å¹¶æš‚åœåç¨‹ã€‚ | å¿…é¡»è¿”å›ä¸€ä¸ª **Awaitable** å¯¹è±¡ï¼ˆé€šå¸¸æ˜¯ `std::suspend_always`ï¼‰ã€‚ |

- å½“ç„¶ï¼Œè¿˜æœ‰ä¸€ä¸ªéƒ¨åˆ†æ˜¯æˆ‘ä»¬éœ€è¦æ³¨æ„çš„â€”â€”æ‚¨å¯ä»¥çœ‹åˆ°ï¼Œå’±ä»¬æœ‰æ—¶å€™è¦æ±‚è¿”å›`std::suspend_always`æˆ–è€…æ˜¯`std::suspend_never`ï¼Œè¿™ä¸ªè™½ç„¶è¡¨è¾¾çš„æ˜¯æˆ‘ä»¬åˆ°åº•è¦ä¸è¦æŒ‚èµ·æ¥åç¨‹ï¼Œä½†æ˜¯è¿™ä¸ªæ¥å£å¹¶ä¸æ˜¯ä¸€å®šè¦è·Ÿ`promise_type`è€¦åˆçš„â€”â€”å®ƒç‹¬ç«‹äºå’±ä»¬çš„`promise_type`ï¼Œå®é™…ä¸Šã€‚ä»–ä¹Ÿéœ€è¦æ»¡è¶³ä¸€ä¸ªæ¥å£ç±»å‹ï¼Œæˆ–è€…è¯´ï¼Œ`std::suspend_always`æˆ–è€…æ˜¯`std::suspend_never`æè¿°çš„æ˜¯æŒ‡å¯¼å’±ä»¬çš„è°ƒåº¦å™¨çš„è¡Œä¸ºç”¨çš„â€”â€”æˆ‘ä»¬å¯ä»¥è‡ªå·±å®ç°ä¸€ä¸ªæ»¡è¶³å¯¹åº”æ¥å£ï¼ˆ`trait`ï¼‰çš„ç±»æ¥å‘Šè¯‰æˆ‘ä»¬è°ƒåº¦å™¨å¦‚ä½•å·¥ä½œâ€”â€”æ˜¯æŒ‚èµ·è¿˜æ˜¯ä¸æŒ‚èµ·ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œéœ€è¦æ»¡è¶³çš„æ¥å£æ˜¯`Awaitable trait`çš„ï¼Œæˆ–è€…æ›´åŠ ç®€å•çš„è¯´ï¼Œä½ æŠŠè¿™ä¸‰ä¸ªå‡½æ•°å®ç°äº†ï¼Œè°ƒåº¦å™¨å°±çŸ¥é“ä½ è¦å¹²å•¥äº†ï¼š

  | æ¥å£ (å‡½æ•°)            | ä½œç”¨           | è§£é‡Š                                                         |
  | ---------------------- | -------------- | ------------------------------------------------------------ |
  | **`await_ready()`**    | **æ˜¯å¦å‡†å¤‡å¥½** | **åˆ¤æ–­æ˜¯å¦éœ€è¦æš‚åœ**ã€‚å¦‚æœè¿”å› `true`ï¼Œè¡¨ç¤ºâ€œå·²ç»å‡†å¤‡å¥½ï¼Œæ— éœ€ç­‰å¾…â€ï¼Œåç¨‹å°†**ç»§ç»­æ‰§è¡Œ**ï¼Œè·³è¿‡ `await_suspend`ã€‚å¦‚æœè¿”å› `false`ï¼Œè¡¨ç¤ºâ€œå°šæœªå‡†å¤‡å¥½ï¼Œéœ€è¦ç­‰å¾…â€ï¼Œåç¨‹å°†è°ƒç”¨ `await_suspend()` è¿›è¡Œæš‚åœæ“ä½œã€‚ |
  | **`await_suspend(H)`** | **æ‰§è¡Œæš‚åœ**   | **æ‰§è¡ŒæŒ‚èµ·åç¨‹çš„é€»è¾‘**ã€‚å½“ `await_ready()` è¿”å› `false` æ—¶è¢«è°ƒç”¨ã€‚å‚æ•° `H` æ˜¯å½“å‰åç¨‹çš„å¥æŸ„ (`std::coroutine_handle<P>`)ã€‚åœ¨è¿™ä¸ªå‡½æ•°å†…éƒ¨ï¼Œä½ å¯ä»¥ä¿å­˜å¥æŸ„ï¼Œå°†å…¶æ”¾å…¥ä»»åŠ¡é˜Ÿåˆ—ï¼Œå¹¶äº¤å‡ºæ§åˆ¶æƒã€‚ |
  | **`await_resume()`**   | **æ¢å¤æ‰§è¡Œ**   | **å¤„ç†æ¢å¤åçš„è¿”å›å€¼**ã€‚å½“åç¨‹è¢«å”¤é†’ (`resume`) åï¼Œè¿™æ˜¯ç¬¬ä¸€ä¸ªæ‰§è¡Œçš„å‡½æ•°ã€‚å®ƒè´Ÿè´£è¿”å›åç¨‹åœ¨æ¢å¤åéœ€è¦ä½¿ç”¨çš„å€¼ï¼ˆå¦‚æœéœ€è¦ï¼‰ã€‚ |

  æˆ‘ä»¬åé¢çš„ç»ƒä¹ ï¼Œè®²è§£ï¼Œå®é™…ä¸Šå°±ç´§ç´§å›´ç»•ç€ä¸‰ä¸ªç¼–è¯‘å™¨çš„æ‰©å±•å…³é”®å­—ï¼Œ6ä¸ªå¿…è¦çš„åç¨‹å¸§**å¯¹è±¡æ¥å£**ï¼ˆä¸ç”¨`co_yield`å°±æ˜¯5ä¸ªï¼Œä¸åŒ…å«`yield_value`äº†ï¼‰å’Œ3ä¸ªéƒ¨åˆ†åç¨‹å¸§å¯¹è±¡æ¥å£è¿”å›çš„æŒ‡å¯¼å¯¹åº”çš„è¡Œä¸ºçš„`Awaitable`å¯¹è±¡çš„**æ¥å£å‡½æ•°**

## å¤ªå¹²äº†ï¼Œæ¥ä¸€ä¸ªä¾‹å­

â€‹	ä¸ºäº†çŸ­æš‚çš„è¯´æ˜æˆ‘ä»¬çš„**åç¨‹çš„å·¥ä½œæµç¨‹**ï¼Œå…‰çœ‹ä¸Šé¢çš„ä¾‹å­ï¼Œæ˜¯ä¸è¶³ä»¥è¯´æ˜ä»»ä½•äº‹æƒ…çš„ã€‚æˆ‘ä»¬éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸€ä¸ªæ‰“ç®—ä½¿ç”¨åç¨‹æ¥ä½œä¸ºè½½ä½“çš„å‡½æ•°ï¼Œéœ€è¦è¿™æ ·å®šä¹‰ä¸€ä¸ªæ¥å£ï¼š

```cpp
åç¨‹è¿”å›ç±»å‹ å‡½æ•°åç§°(å‚æ•°åˆ—è¡¨);
```

â€‹	æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¿«é€Ÿçš„èµ·ä¸€ä¸ªè‰ç¨¿ä»£ç ï¼š

```cpp

bool quit_flag = 0; // è¿™ä¸ªquit_flagç”¨æ¥æ ‡è¯†Mainçš„é€€å‡ºï¼Œè¿™æ ·æˆ‘ä»¬æ‰èƒ½çœ‹åˆ°å’±ä»¬çš„åç¨‹çš„å·¥ä½œ
int main() {
	dump_time();
	std::println("Ready to involk task()");
	auto result = task(); // æ¥å—åç¨‹æ¥å£æ”¯æŒçš„æ ˆå¸§ç»“æ„ä½“
	std::println("Result here: {}", result.value());
	while (!quit_flag)	// å¡åœ¨è¿™é‡Œï¼Œæ¼”ç¤ºå®Œæ•´çš„æµç¨‹
		;

	std::println("Result here: {}", result.value());

	return 0;
}
```

> dump_timeæ˜¯ç¬”è€…ç”¨æ¥æ‰“å°æ‰§è¡Œäº‹ä»¶çš„å‡½æ•°ï¼Œè¿™é‡Œç»™å‡ºå®šä¹‰ï¼Œæˆ‘ä»¬åé¢æ‰“å°çš„æ—¶å€™è¿˜ä¼šç”¨åˆ°ã€‚
>
> ```cpp
> void dump_time() {
> 	auto now = std::chrono::system_clock::now();
> 	std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
> 	std::tm localTime;
> #ifdef _WIN32
> 	localtime_s(&localTime, &currentTime); // Windows å¹³å°
> #else
> 	localtime_r(&currentTime, &localTime); // Linux/Unix å¹³å°
> #endif
> 	std::cout << std::put_time(&localTime,
> 	                           "%H:%M:%S")
> 	          << " :";
> }
> ```

â€‹	ä¸‹ä¸€æ­¥ï¼Œå°±æ˜¯å®šä¹‰å’±ä»¬çš„åç¨‹è¿”å›ç±»å‹ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸Šé¢çš„ç¬”è®°å·²ç»è¯´æ˜äº†å’±ä»¬çš„åç¨‹è¿”å›ç±»å‹è¦å­˜åœ¨å†…åµŒçš„æŒ‡å®šç±»å‹`promise_type`ï¼Œè¿™é‡Œç»™å‡ºç±»å‹ï¼ˆæ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªç±»å‹å¿…é¡»æ˜¯publicçš„ï¼Œè°ƒåº¦å™¨ä¼šç›´æ¥è®¿é—®è¿™äº›æ¥å£å‡½æ•°ï¼‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹æˆ‘ä»¬è¦å’‹å†™ï¼Œæ‰èƒ½è®©å‡½æ•°æ”¯æŒåœ¨åç¨‹ä¸Šè¿ä½œâ€”â€”

```cpp
template<typename T>
struct MyTask { // MyTaskçš„åç§°æ˜¯éšæ„çš„
	struct promise_type { 
        // promise_typeä¸å¯ä»¥éš
        // åœ¨coroutineæ–‡ä»¶ä¸­å·²ç»è¦æ±‚äº†è¿™ä¸ªç±»å‹çš„å­˜åœ¨
        
        // è¿”å›çš„æ˜¯å’±ä»¬çš„åç¨‹è¿”å›ç±»å‹ï¼Œè¿™ä¸ªæ—¶å€™å¤–ç•Œè°ƒç”¨çš„åç¨‹å‡½æ•°è¿”å›çš„å¯¹è±¡å°±æ˜¯MyTask
        // å®é™…ä¸Šå°±æ˜¯ä¿å­˜å’±ä»¬çš„åç¨‹ç›¸å…³çš„å†…å®¹çš„ç»“æ„ä½“, æˆ‘ä»¬å…³å¿ƒçš„ä¸€äº›ç»“æœå°±åœ¨è¿™ä¸ªè¿”å›çš„ç»“æ„ä½“ä¸­
        MyTask get_return_object() { ... }
        
        // ä¸æŒ‚èµ·çš„ç‰ˆæœ¬, è¿”å›çš„æ˜¯ std::suspend_never, initial_suspendåœ¨ä¸Šé¢çš„ç¬”è®°ä¸­è°ˆåˆ°
        // ä»–æ˜¯ç”¨æ¥åç¨‹æ ˆå¸§é¦–æ¬¡è¢«åˆ›å»ºçš„æ—¶å€™, ç”¨æ¥å‘Šè¯‰è°ƒåº¦å™¨è¦ä¸è¦æŒ‚èµ·çš„, suspend_neverå°±æ˜¯
        // ä¸è¦æŒ‚èµ·ï¼Œç›´æ¥è·‘
        // å¦‚æœè¿”å›çš„æ˜¯ std::suspend_always, é‚£å°±æ˜¯åˆ›å»ºå®Œé©¬ä¸ŠæŒ‚èµ·ï¼Œéœ€è¦ä»–è·‘èµ·æ¥ï¼Œ
        // æˆ‘ä»¬å°±éœ€è¦æ‰‹åŠ¨æ”¾ä¸‹ï¼Œæ‰“ä¸ªç±»æ¯”çš„è¯â€”â€”Windowsåˆ›å»ºçº¿ç¨‹orè¿›ç¨‹æ‚¨å¯ä»¥æ§åˆ¶å®ƒåˆ°åº•è¿è¡Œä¸è¿è¡Œ
        // å¦‚æœåˆ›å»ºå³æŒ‚èµ·ï¼Œé‚£ä¹ˆåé¢æˆ‘ä»¬è°ƒç”¨resumeæ¥å£å°±èƒ½è§£å†³è¿™ä¸ªé—®é¢˜, æ–¹ä¾¿èµ·è§è¿™é‡Œä¸æŒ‚èµ·
        std::suspend_never initial_suspend() { ... }
        
        // è¿™ä¸ªæ˜¯åç¨‹åœ¨æ‰§è¡Œå®Œæ¯•çš„æ—¶å€™ï¼Œè°ƒåº¦å™¨ä¼šåœ¨å¯¹è±¡æœ¬æ¥åº”è¯¥ææ„çš„å‰å¤•ï¼Œå†³å®š
        // è¦ä¸è¦æŒ‚èµ·æ¥è¿™ä¸ªåç¨‹ï¼Œè¿™é‡ŒæŒ‚èµ·æ˜¯ä¸ºäº†é˜²æ­¢å¯¹è±¡ç›´æ¥è¢«ææ„å¹²å‡€äº†ï¼Œæˆ‘ä»¬æ–¹ä¾¿æ£€æŸ¥ç‚¹å†…å®¹
        // è¿™é‡Œå°±å…ˆæŒ‚èµ·ï¼Œå½“ç„¶å¦‚æœä½ çš„åç¨‹å•çº¯çš„æ˜¯åšè‹¦åŠ›ï¼Œä¸ä¿å­˜ä»»ä½•å…¶ä»–ä¸œè¥¿ï¼Œè¿”å›
        // std::suspend_never
        std::suspend_always final_suspend() noexcept { ... }
        
        // co_returnçš„æ—¶å€™ï¼Œè°ƒç”¨çš„å°±æ˜¯è¿™ä¸ªä¸œè¥¿â€”â€”è¯´èµ·æ¥å¾ˆç®€å•ï¼Œreturnçš„ä¸œè¥¿ä¼šç«‹é©¬è¢«è½¬å‘åˆ°
        // return_valueé‡Œä¿å­˜èµ·æ¥ï¼Œæˆ‘ä»¬åé¢ä½¿ç”¨çš„æ—¶å€™ï¼Œå°±è®¿é—®å¯¹åº”çš„MyTaskç±»å‹ä¿å­˜çš„å†…å®¹ï¼ˆ
        // ä¸€èˆ¬è€Œè¨€ï¼Œå’±ä»¬éƒ½æ˜¯æ‰”åˆ°Taskç»“æ„ä½“ä¸­ç»“æŸçš„ï¼‰
        void return_value(T value) { ... }
        
        // è¿™ä¸ªéƒ¨åˆ†æ˜¯å¦‚æœæˆ‘ä»¬ç›´æ¥throwäº†å¼‚å¸¸ï¼Œç¼–è¯‘å™¨ä¼šæŠŠé‚£äº›æ²¡æœ‰å¤„ç†çš„å¼‚å¸¸æ‰”åˆ°è¿™ä¸ªå‡½æ•°é‡Œ
        // ä¸€èˆ¬æˆ‘ä»¬ä¸åšä»»ä½•å¤„ç†ï¼Œå½“ç„¶ï¼Œå¦‚æœæ‚¨éœ€è¦å¤„ç†ä¸€éƒ¨åˆ†å¼‚å¸¸ï¼ŒæŠŠä½ çš„å®ç°æ”¾åˆ°è¿™é‡Œ
        void unhandled_exception() { }
    };
};
```

â€‹	ä¸‹é¢ç¬”è€…æŠŠè¿™ä¸ªç»“æ„ä½“å®ç°äº†â€”â€”å®é™…ä¸Šå­˜ç•™çš„æ˜¯ä¸€ä¸ªintä½œä¸ºç»“æœï¼Œè‡ªç„¶ä¹Ÿå°±è¿™æ ·ç¼–å†™ä»£ç ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯â€”â€”è¿™é‡Œç¬”è€…å¾ˆå¤šå†…å®¹éƒ½æ˜¯åœ¨æ‰“å°æ—¥å¿—ã€‚

```cpp
struct Task {
	struct promise_type {
		promise_type()
		    : __value(std::make_shared<int>()) {
			dump_time();
			std::println("Task::promise_type::promise_type is involked!");
		}
		Task get_return_object() {
			dump_time();
			std::println("Task::promise_type::get_return_object is involked!");
			return Task { __value };
		}
		std::suspend_never initial_suspend() {
			dump_time();
			std::println("Task::promise_type::initial_suspend is involked!");
			return {};
		}
		std::suspend_always final_suspend() noexcept {
			// even though we returns the std::suspend_always
			// the co-ro will dashed after the quit flags are set as 1
			// main will quit, and you wont see the program stuck
			dump_time();
			std::println("Task::promise_type::final_suspend is involked!");
			return {};
		}
		void return_value(int value) {
			dump_time();
			std::println("Task::promise_type::return_value is involked!");
			*__value = value;
			/**
			 * 	Warning: dont write codes like that in
			 *	production env, this is unsafe
			 */
			quit_flag = 1; // OK, main can quit then
		}
		void unhandled_exception() { }

	private:
		std::shared_ptr<int> __value;
	};

	Task(std::shared_ptr<int> v)
	    : __value(v) {
		dump_time();
		std::println("Task is created!");
	}

	int value() const { return *__value; }

private:
	std::shared_ptr<int> __value;
};
```

â€‹	æˆ‘ä»¬ç°åœ¨çš„taskå‡½æ•°å¯ä»¥å‡†å¤‡å®ç°äº†ï¼Œå¯ä»¥æ”¾åˆ°ä¸‹é¢æ¥çœ‹çœ‹ã€‚

```cpp
Task task() {
	SimpleReader reader1;
	dump_time();
	std::println("CoAwait the reader1");
	int tol = co_await reader1;
	std::println("tol: {}", tol);

	SimpleReader reader2;
	dump_time();
	std::println("CoAwait the reader2");
	tol += co_await reader2;
	std::println("tol: {}", tol);

	SimpleReader reader3;
	dump_time();
	std::println("CoAwait the reader3");
	tol += co_await reader3;
	std::println("tol: {}", tol);

	dump_time();
	std::println("Ready to co_return");

	co_return tol;
}
```

â€‹	æˆ‘ä»¬å¯ä»¥çœ‹åˆ°`SimpleReader`è¢«`co_await`äº†ï¼Œæ‰€ä»¥SimpleReaderå¿…é¡»æ˜¯ä¸€ä¸ªAwaitableå¯¹è±¡ã€‚æˆ‘ä»¬æ—©åœ¨ä¹‹å‰å°±æåˆ°äº†Awaitableå¯¹è±¡å¿…é¡»æ»¡è¶³ä¸‰ä¸ªæ¥å£æ¥æŒ‡å¯¼è°ƒåº¦å™¨å·¥ä½œï¼š

```cpp
struct SimpleReader {
    // await_readyæ˜¯æˆ‘ä»¬çš„co_awaitè¯­å¥ä¸€æ‰§è¡Œï¼Œç¼–è¯‘å™¨ç«‹é©¬å°±ä¼šè½¬å‘åˆ°è¿™ä¸ªå‡½æ•°é‡Œæ¥
    // falseå°±è¡¨æ˜ï¼Œå’±ä»¬çš„Awaitableå¯¹è±¡æ²¡æœ‰é¢„å¤‡å¥½
    // å¯ä»¥æ‹¿æ›´åŠ åœºæ™¯åŒ–çš„ä¾‹å­ä¸¾ä¾‹â€”â€”IOäº‹ä»¶æ²¡æœ‰å‡†å¤‡ï¼Œåç¨‹åŒ–çš„å¯¹è±¡è¿™é‡Œå°±è¦è¿”å›IOæ˜¯å¦åšå¥½äº†
	bool await_ready() {
		dump_time();
		std::println("call await_ready, always return false");
		return false;
	}

    // å½“æˆ‘ä»¬è°ƒç”¨æ¢å¤resumeæ¥å£çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨ç«‹é©¬å°±ä¼šè½¬å‘åˆ°await_resumeä¸Šï¼Œå®é™…ä¸Šæˆ‘ä»¬è¦æ±‚è¿”å›çš„å°±æ˜¯co_awaitçš„ç»“æœï¼Œtask()ä»£ç ä¸­æˆ‘ä»¬æ˜¯int tol = co_await reader1, æ‰€ä»¥ï¼Œè¿™é‡Œçš„return valueå°±ä¼šç›´æ¥è¿”å›ç»™tol
	int await_resume() {
		dump_time();
		std::println("call await_resume, return the current value: {}", value);
		return value;
	}

    // å½“æˆ‘ä»¬çš„await_readyè¿”å›å¦çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨ç«‹é©¬æŒ‚èµ·åç¨‹ï¼Œå¹¶ä¸”èµ°å¤„ç†å›è°ƒawait_suspend
    // å½“ç„¶ï¼Œç¼–è¯‘å™¨å¥½å¿ƒçš„å¸®åŠ©æˆ‘ä»¬ä¼ é€’è¿›æ¥äº†åç¨‹çš„handle: std::coroutine_handle<>ï¼Œ è¿™ä¸ªæ¥å£è¢«	
    // ç”¨æ¥åè°ƒ æˆ‘ä»¬å¯ä»¥å¦‚ä½•æ“ä½œè¿™ä¸ªåç¨‹handleï¼Œç¬”è€…è¿™é‡Œå°±å†³å®šæ‰”åˆ°ä¸€ä¸ªè„±ç¦»ä¸»çº¿ç¨‹çš„å­çº¿ç¨‹
    // æ‹¿åˆ°valueåç›´æ¥æ”¾ä¸‹åç¨‹ç»§ç»­æ‰§è¡Œ
	void await_suspend(std::coroutine_handle<> handle) {
		dump_time();
		std::println("call await_suspend, creating a detached thread");
		std::thread worker([this, handle]() {
			std::this_thread::sleep_for(1s);
			value = 1;
			handle.resume(); // resume the await, will later involk await_resume
		});

		worker.detach();
	}

private:
	int value { 0 };
};
```

â€‹	æ•´ä¸ªä»£ç ç¬”è€…æ”¾åˆ°é™„å½•äº†ã€‚æ‚¨ç°åœ¨å¯ä»¥è·³åˆ°é™„å½•ä¸€æŸ¥çœ‹ä»£ç ï¼Œæ€è€ƒä¸€ä¸‹ç¨‹åºçš„è¾“å‡ºã€‚

â€‹	ç¼–è¯‘æ‰§è¡Œåï¼Œå¾—åˆ°ä¸‹é¢çš„æ—¥å¿—ç»“æœã€‚çœ‹çœ‹æ‚¨æƒ³çš„å¯¹ä¸å¯¹ï¼Ÿ

```
19:24:06 :Ready to involk task()
19:24:06 :Task::promise_type::promise_type is involked!
19:24:06 :Task::promise_type::get_return_object is involked!
19:24:06 :Task is created!
19:24:06 :Task::promise_type::initial_suspend is involked!
19:24:06 :CoAwait the reader1
19:24:06 :call await_ready, always return false
19:24:06 :call await_suspend, creating a detached thread
Result here: 0
19:24:07 :call await_resume, return the current value: 1
tol: 1
19:24:07 :CoAwait the reader2
19:24:07 :call await_ready, always return false
19:24:07 :call await_suspend, creating a detached thread
19:24:08 :call await_resume, return the current value: 1
tol: 2
19:24:08 :CoAwait the reader3
19:24:08 :call await_ready, always return false
19:24:08 :call await_suspend, creating a detached thread
19:24:09 :call await_resume, return the current value: 1
tol: 3
19:24:09 :Ready to co_return
19:24:09 :Task::promise_type::return_value is involked!
19:24:09 :Task::promise_type::final_suspend is involked!
Result here: 3
```

â€‹	æ‚¨å¯¹ç…§ç¬”è®°ï¼Œå¾ˆå®¹æ˜“å°±ææ¸…æ¥šæˆ‘ä»¬çš„ä»£ç å‘ç”Ÿäº†ä»€ä¹ˆã€‚

## ç»ƒä¹ 2ï¼šåˆ©ç”¨åç¨‹æ¥ç¼–å†™ç”Ÿæˆå™¨ï¼ˆGeneratorï¼‰

â€‹	è¿™é‡Œçš„ç”Ÿæˆå™¨ï¼Œæ›´å¤šçš„æ˜¯è¯´æ˜åç¨‹å¼‚æ­¥çš„å‡†å¤‡ç»“æœï¼Œå½“æˆ‘ä»¬éœ€è¦çš„æ—¶å€™ï¼Œæˆ‘ä»¬æ‰¾åç¨‹ä¿å­˜çš„ç»“æ„ä½“ä¸­ç´¢è¦æˆ‘ä»¬æœŸå¾…çš„å†…å®¹ï¼Œçœ‹èµ·æ¥å°±åƒæ˜¯åç¨‹å˜å‡ºæ¥æˆ‘ä»¬æƒ³è¦çš„ä¸œè¥¿â€”â€”ç”Ÿæˆå™¨å› æ­¤è€Œå¾—åã€‚

â€‹	ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥ç¼–å†™è‡ªå·±çš„ç”Ÿæˆå™¨ï¼Œæ¥å¾ªç¯è¾“å‡ºæŒ‡å®šä¸Šä¸‹ç•Œçš„æ¯ä¸€ä¸ªæ•´æ•°ã€‚ç­¾åçº¦å®šå¦‚ä¸‹ï¼š

```cpp
Generator<int> iterate_value(int start, int end) {
	// implement codes here
}

int main() {
	simple_log("Ready to start the range loop");

	for (int queried_value : iterate_value(1, 10)) {
		std::println("get the iterative value: {}", queried_value);
	}

	simple_log("the range loop Finished!");
}
```

#### ä¸€äº›æ€è€ƒ

â€‹	å¦‚æœä½ å®åœ¨æ²¡æœ‰æ€è·¯ï¼Œå¬æˆ‘è¯´è¯´ï¼Ÿ

1. é¦–å…ˆï¼Œç¬”è€…è¿™é‡Œçš„é¢˜ç›®å‡ºç°äº†ç»å…¸çš„`for(int queried_value : iterate_value(1, 10))`æ ·å¼çš„ä»£ç ï¼Œç»“åˆSTLçš„çº¦æŸæ ‡å‡†ï¼Œä»»ä½•è¿™æ ·çš„`iteratable-for-loop`è¦æ±‚è¢«è¿­ä»£çš„å¯¹è±¡æä¾›ä¸¤ä¸ªæ¥å£ï¼š`begin`å’Œ`end`ï¼Œç”±äºæˆ‘ä»¬è¿™ä¸ªæ˜¯åç¨‹å‡½æ•°ï¼Œå®é™…ä¸Šè¿”å›çš„ï¼Œå¦‚æ‚¨çœ‹åˆ°æ¥å£æ‰€ç¤ºçš„æ˜¯â€”â€”`Generator<int>`ï¼Œè¯´æ˜ç”Ÿæˆå™¨è‡ªèº«è¦æ»¡è¶³å¯è¿­ä»£çš„ä¸¤ä¸ªæ¥å£`begin`å’Œ`end`
2. ä¸‹ä¸€ä¸ªé—®é¢˜â€”â€”ä»€ä¹ˆæ—¶å€™å¯¹è±¡å˜å¾—å¯è¿­ä»£å‘¢ï¼Ÿç­”æ¡ˆæ˜¯â€”â€”åç¨‹æ”¾ä¸‹ï¼Œç”Ÿæˆå™¨å¯è¿­ä»£ã€‚åç¨‹æ”¾ä¸‹è®©ç”Ÿæˆå™¨å¯è¿­ä»£å¤ªéš¾äº†ï¼Œè¦ä¸è¦åè¿‡æ¥æ€è€ƒâ€”â€”ç”Ÿæˆå™¨è°ƒç”¨`begin()`çš„æ—¶å€™åç¨‹æ”¾ä¸‹å¯ä»¥è¿ä½œï¼Ÿè¿™æ ·åé¢çš„è¿­ä»£ä¹Ÿå¥½åŠï¼è¿­ä»£åˆ°ä¸‹ä¸€ä¸ªçš„æ—¶å€™å’±ä»¬å°±æ”¾ä¸‹åç¨‹äº§ç”Ÿæ–°çš„å†…å®¹ã€‚å½“æˆ‘ä»¬çš„åç¨‹è¿ä½œç»“æŸï¼Œç”Ÿæˆå™¨è‡ªç„¶ä¹Ÿå°±ä¸å¯è¿­ä»£äº†ï¼è¿™ä¸ªæ—¶å€™å°±ä½œä¸º`end()`ï¼Œæ€ä¹ˆæ ·ï¼Ÿ
3. è¿”å›å›æ¥çš„å€¼ï¼Œæ˜¾ç„¶éœ€è¦æˆ‘ä»¬åšå¤„ç†ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬æ‹¿åˆ°çš„æ˜¯ç”Ÿæˆå™¨ï¼Œè€Œä¸æ˜¯æˆ‘ä»¬å…³å¿ƒçš„å€¼â€”â€”è¿­ä»£å™¨çš„æ“ä½œç¬¦*æ˜¾ç„¶å°±å¯ä»¥å‘åŠ›äº†â€”â€”åœ¨æˆ‘ä»¬åšè§£å¼•ç”¨çš„æ—¶å€™ï¼Œå°±æŠŠæˆ‘ä»¬å…³å¿ƒçš„å€¼ä»è¿­ä»£å™¨ä¸­è¿”å›å‡ºå»â€”â€”è¿™ä¹Ÿæ˜¯è¿­ä»£å™¨æŠ½è±¡å­˜åœ¨çš„ç†ç”±ï¼Œå¯¹ä¸å¯¹ï¼Ÿ
4. ç”Ÿå‘½å‘¨æœŸçš„é—®é¢˜â€”â€”åç¨‹è¦ä¸è¦co_returnäº†ç«‹é©¬è¢«é”€æ¯å‘¢ï¼Ÿæ˜¾ç„¶ä¸å¯ä»¥ï¼Œå› ä¸ºæˆ‘ä»¬çš„ç”Ÿæˆå™¨å…³å¿ƒçš„å€¼è¿˜å­˜å‚¨åœ¨åç¨‹è¿”å›ç±»å‹å¥æŸ„ä¸­ï¼Œé‚£æˆ‘ä»¬å°±å€’è¿‡æ¥æƒ³â€”â€”ç”Ÿæˆå™¨ç»“æŸäº†å®ƒçš„å£°æ˜å‘¨æœŸï¼Œå’±ä»¬çš„åç¨‹æ˜¾ç„¶ä¹Ÿå°±è¿ä½œå®Œæ¯•ï¼Œç”±ç”Ÿæˆå™¨é”€æ¯å’±ä»¬çš„åç¨‹ï¼Œæ˜¾ç„¶æ‰æ˜¯æ­£ç¡®çš„å†³ç­–ã€‚

ä»£ç æ²¡æœ‰ä»€ä¹ˆæ–°é²œçš„ï¼Œç¬”è€…å·²ç»æ”¾åˆ°é™„å½•ä¸­äº†ã€‚

# å‚è€ƒ

> ä¸»è¦çš„å‚è€ƒï¼š[åç¨‹ (C++20) - cppreference.cn - C++å‚è€ƒæ‰‹å†Œ](https://cppreference.cn/w/cpp/language/coroutines)
>
> è¿™äº›è§†é¢‘æ•™ç¨‹ç¬”è€…çœ‹äº†ï¼Œä½†æ˜¯è´¨é‡å„ä½è‡ªè¡Œè¯„åˆ¤ï¼Œç¬”è€…åªæ˜¯è¯šå®çš„æšä¸¾æˆ‘çœ‹äº†ä»€ä¹ˆ
>
> - [C++20 åç¨‹ï¼Œ99% çš„ç¨‹åºå‘˜éƒ½æ²¡å®Œå…¨ææ‡‚ï¼ä½ è¦åšé‚£ 1% å—ï¼Ÿ è¿™å¯èƒ½æ˜¯å…¨ç½‘C++åç¨‹è®²çš„æœ€å¥½çš„è§†é¢‘_bilibili](https://www.bilibili.com/video/BV1Cz9NYFE8E/)
> - [C++20åç¨‹æ•™ç¨‹_bilibili](https://www.bilibili.com/video/BV1JN411y7Bx)

# é™„å½•

> co1.cpp

```cpp
#include <coroutine>
#include <iomanip>
#include <iostream>
#include <memory>
#include <print>
#include <thread>
using namespace std::chrono_literals;

void dump_time() {
	auto now = std::chrono::system_clock::now();
	std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
	std::tm localTime;
#ifdef _WIN32
	localtime_s(&localTime, &currentTime); // Windows å¹³å°
#else
	localtime_r(&currentTime, &localTime); // Linux/Unix å¹³å°
#endif

	std::cout << std::put_time(&localTime,
	                           "%H:%M:%S")
	          << " :";
}

struct SimpleReader {
	bool await_ready() {
		dump_time();
		std::println("call await_ready, always return false");
		return false;
	}

	int await_resume() {
		dump_time();
		std::println("call await_resume, return the current value: {}", value);
		return value;
	}

	void await_suspend(std::coroutine_handle<> handle) {
		dump_time();
		std::println("call await_suspend, creating a detached thread");
		std::thread worker([this, handle]() {
			std::this_thread::sleep_for(1s);
			value = 1;
			handle.resume(); // resume the await
		});

		worker.detach();
	}

private:
	int value { 0 };
};

bool quit_flag = 0;

struct Task {
	struct promise_type {
		promise_type()
		    : __value(std::make_shared<int>()) {
			dump_time();
			std::println("Task::promise_type::promise_type is involked!");
		}
		Task get_return_object() {
			dump_time();
			std::println("Task::promise_type::get_return_object is involked!");
			return Task { __value };
		}
		std::suspend_never initial_suspend() {
			dump_time();
			std::println("Task::promise_type::initial_suspend is involked!");
			return {};
		}
		std::suspend_always final_suspend() noexcept {
			// even though we returns the std::suspend_always
			// the co-ro will dashed after the quit flags are set as 1
			// main will quit, and you wont see the program stuck
			dump_time();
			std::println("Task::promise_type::final_suspend is involked!");
			return {};
		}
		void return_value(int value) {
			dump_time();
			std::println("Task::promise_type::return_value is involked!");
			*__value = value;
			/**
			 * 	Warning: dont write codes like that in
			 *	production env, this is unsafe
			 */
			quit_flag = 1; // OK, main can quit then
		}
		void unhandled_exception() { }

	private:
		std::shared_ptr<int> __value;
	};

	Task(std::shared_ptr<int> v)
	    : __value(v) {
		dump_time();
		std::println("Task is created!");
	}

	int value() const { return *__value; }

private:
	std::shared_ptr<int> __value;
};

Task task() {
	SimpleReader reader1;
	dump_time();
	std::println("CoAwait the reader1");
	int tol = co_await reader1;
	std::println("tol: {}", tol);

	SimpleReader reader2;
	dump_time();
	std::println("CoAwait the reader2");
	tol += co_await reader2;
	std::println("tol: {}", tol);

	SimpleReader reader3;
	dump_time();
	std::println("CoAwait the reader3");
	tol += co_await reader3;
	std::println("tol: {}", tol);

	dump_time();
	std::println("Ready to co_return");

	co_return tol;
}

int main() {
	dump_time();
	std::println("Ready to involk task()");
	auto result = task();
	std::println("Result here: {}", result.value());
	while (!quit_flag)
		;

	std::println("Result here: {}", result.value());

	return 0;
}
```

> co2_self.cpp

```cpp
#include "helpers.h"
#include <coroutine>
#include <format>
#include <print>

/**
 * @brief   class Generator will be the coroutine return handles
 *          We have said that we need to inplace a promise_type
 *          for coroutine schedular to co-operate the task
 */
template <typename T>
class Generator {
public:
	// to simplied the code, lets take it easy
	// make a new type coro_handle
	struct promise_type;
	using coro_handle = std::coroutine_handle<promise_type>;

	/**
	 * @brief Construct a new Generator object
	 *
	 * @param h
	 */
	Generator(coro_handle h)
	    : handle(h) {
		simple_log_with_func_name();
	}

	~Generator() {
		if (handle)
			// we return std::suspend_always
			// so we need to clean up everything here
			handle.destroy();
	}

	class Iterator {
	public:
		Iterator(coro_handle h)
		    : handle(h) {
		}

		bool operator!=(const Iterator& other) const {
			return handle // happens in end()
			    && !handle.done(); // or the coroutine is shutdown
		}

		Iterator& operator++() {
			if (handle) {
				handle.resume(); // resume util next co_yield!
			}
			return *this;
		}

		T operator*() const {
			if (!handle || !handle.promise()._value) {
				throw std::runtime_error("Dereferencing invalid iterator");
			}
			return handle.promise()._value;
		}

	private:
		coro_handle handle;
	};

	Iterator begin() {
		if (handle) {
			// resume as the initial suspend
			// hang up the co-routine
			handle.resume();
		}
		return Iterator { handle };
	}

	Iterator end() {
		// to manual trigger the != sessions
		return Iterator { nullptr };
	}

	// Must be name promise_type, we need to implement following
	// interfaces:
	struct promise_type {
		promise_type() {
			simple_log_with_func_name();
		} // nothing special for the promise_type

		Generator get_return_object() noexcept {
			simple_log_with_func_name();
			// Create the Generator for outlayer caller
			return { coro_handle::from_promise(*this) };
		}

		// We need to suspend as we need to let them work
		// until the Iterator access the value
		std::suspend_always initial_suspend() {
			simple_log_with_func_name();
			return {};
		}

		// suspend the co-routine up
		std::suspend_always final_suspend() noexcept {
			simple_log_with_func_name();
			return {};
		}

		// when involk co_yield, these functions work
		std::suspend_always yield_value(T value) {
			simple_log_with_func_name(
			    std::format("yield_value with {}", value));
			_value = std::move(value); // move the value
			return {}; // suspend the session
		}

		// dont handle the exception
		void unhandled_exception() { }

		// internal value
		T _value {};
	};

private:
	coro_handle handle;
};

Generator<int> iterate_value(int start, int end) {
	for (int i = start; i < end; i++) {
		// every time, what we involk
		co_yield i;
	}
}

int main() {
	simple_log("Ready to start the range loop");

	for (int queried_value : iterate_value(1, 10)) {
		// explain the code if you are not familiar with
		// STL iterations, for any FOR LOOP with iteratable objects
		// which requires the begin() and end() interfaces
		// we get the call as followings
		// 1.   call Generator<int>::begin() -> Iterator to get the initial iterators
		//      at this case, begin() will resume the co-routine which is suspend initially
		// 2.   co_yield i will call yield_value and stores i into _value,
		//      which later will be placed in hereby queried_value, as operator* is called, we will get the
		//      result stores in the promise_type
		// 3.   then we continue as it is not the end (func iterate_value dont reach co_return implicitly)
		// 4.   so, we will call operator++, which will call co_yield again, we shell return the next value
		// 5.   goto step 2 again
		// 6.   util the end, we will reach co_return, as i == end, then the
		//      co-routines are suspend, as the Iterator::end() == current_iterator, with coroutine invalid already!
		// 7.   so, loop will quit
		std::println("get the iterative value: {}", queried_value);
	}

	simple_log("the range loop Finished!");
}
```

> è¿˜æœ‰ä¸€äº›è¾…åŠ©å‡½æ•°ï¼Œç¬”è€…ä¹Ÿæ”¾åˆ°ä¸‹é¢å»ï¼š
>
> helpers.h

```cpp
#pragma once
#include <source_location>
#include <string>
void simple_log(const std::string& v, bool request_dump_time = true);

void simple_log_with_func_name(
    const std::string& other = "",
    const std::string& func_name
    = std::source_location::current().function_name(),
    bool request_dump_time = true);
```

> helpers.cpp

```cpp
#include "helpers.h"
#include <chrono>
#include <format>
#include <iomanip>
#include <iostream>
#include <print>

namespace {
void dump_time() {
	auto now = std::chrono::system_clock::now();
	std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
	std::tm localTime;
#ifdef _WIN32
	localtime_s(&localTime, &currentTime); // Windows å¹³å°
#else
	localtime_r(&currentTime, &localTime); // Linux/Unix å¹³å°
#endif

	std::cout << std::put_time(&localTime,
	                           "%H:%M:%S")
	          << " :";
}
}
void simple_log(const std::string& v, bool request_dump_time) {
	if (request_dump_time) {
		dump_time();
	}
	// logings
	std::println("{}", v);
}

void simple_log_with_func_name(
    const std::string& other,
    const std::string& func_name,
    bool request_dump_time) {

	simple_log(std::format(
	               "function: {} is involked, {}", func_name, other),
	           request_dump_time);
}
```

