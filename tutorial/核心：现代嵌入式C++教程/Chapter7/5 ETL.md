# 嵌入式C++教程——ETL（Embedded Template Library）

好奇心：为什么在嵌入式世界里，总有人把 `new` 当成“危险品”而随身带手套？答案很简单：堆是不可预测的。ETL（Embedded Template Library）就是为了解决这个问题而生：把熟悉的容器/算法思想搬到嵌入式场景，但把动态分配剔除掉，让一切变得可预测、可度量、可审计。

------

## ETL 是啥

ETL 是一个面向嵌入式的 C++ 模板库（作者/维护在 GitHub 上，采用 MIT 许可证），它提供了许多类似 STL 的容器与工具，但所有容器都是**固定容量**或**最大容量**的 —— 不会调用 `malloc/new`，因此非常适合对内存可控性有严格要求的系统。它兼容较老的编译器和嵌入式工具链（设计目标覆盖 C++03 及更高版本的环境）。

------

## 为什么用 ETL

你可以把 ETL 看成一个“没有动态分配的 STL 副本”：它保留了熟悉的 API 风格（对程序员友好），同时把内存以静态/栈/预分配块的形式提前分配好——这带来两个直接好处：

- **确定性**：不再担心 heap 碎片、分配失败或无法预测的延迟。
- **性能与缓存友好**：容器的存储通常是连续分配的，遍历时更亲近 CPU 缓存。

总之：你想要 STL 的便捷，但又要裸机级的可预测性，ETL 很合适。

------

## 核心特性

ETL 的设计重点可浓缩为几句话：固定/最大容量容器（向量、队列、链表、map 等变体）、无堆分配、与 STL 风格 API 兼容（尽量）、MIT 开源并在 GitHub 活跃维护。你可以在 Arduino / PlatformIO / 各种嵌入式生态里找到它的移植或封装。

------

## 快速上手

下面是一个最小示例：固定容量的向量（注意：实际头文件名与命名空间以你用的 ETL 版本为准）：

```cpp
#include <etl/vector.h>
#include <iostream>

int main() {
    // 最大容量 8 的静态向量，内存事先分配好（无动态分配）
    etl::vector<int, 8> v;

    for (int i = 0; i < 6; ++i) {
        v.push_back(i * 10); // 如果超过容量，会有 safe variant 报错或返回错误（取决于配置）
    }

    for (auto it = v.begin(); it != v.end(); ++it) {
        std::cout << *it << "\n";
    }

    // 指定位置插入/删除等 API 很像 STL
    v.insert(v.begin() + 2, 99);
}
```

提示：ETL 的容器通常以模板参数指定容量（或用 `etl::pool` 类别的方式管理对象池），所以在编译期就能知道内存占用。

------

## ETL 的局限

ETL 并不打算替代 STL 在所有场景的地位——它是“为嵌入式量身定做的替代/补充”。如果你项目中对象来自第三方库且无法改造，或者你确实需要动态增长到不确定的大小，STL（或堆）仍然是更方便的选择。ETL 的静态分配还可能导致二进制体积增加（模板实例化），需要权衡编译时的代码膨胀问题

所以 ETL 不是魔法，而是工程上的折衷 —— 它用模板把“静态内存 + 熟悉 API”这两个愿望合二为一。对于需要确定性、低内存开销、对实时性有要求的系统（比如 bootloader、RTOS 任务队列、驱动层 buffer 管理），ETL 是一把好刀。拿它来修理日常的内存问题，往往比带着 `malloc` 在板子上做瑜伽要稳妥得多

