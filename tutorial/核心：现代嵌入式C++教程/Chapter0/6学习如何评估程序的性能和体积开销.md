# 现代嵌入式C++教程——C++一定会使得代码膨胀嘛？

关于性能评估和程序体积大小，我相信，各位程序员可能对前者更加有感觉，对后者还是会略微陌生一点——特别是上位机开发的朋友。我相信在大家觉得硬存越来越不值钱的今天，很少人会关心上位机程序的发布包大小了。不过在嵌入式，一点Flash跟个金子一样珍贵的行业中，还是有必要考虑下程序体积大小的。

这就引发了一个问题，大家知道这里是《现代嵌入式C++教程》（有时候，笔者写成了嵌入式现代C++教程），但是这个问题是一个老生常谈但又永远充满争议的话题：**C++一定会使得代码膨胀嘛？**

## 开始之前，磨刀不误砍柴工

在开始我们的代码大战之前，先确保你的工具箱里有这些家伙：

#### arm-none-eabi-gcc / arm-none-eabi-g++

这个是X86_64对ARM平台的交叉编译器，咱们走一下：

```
[charliechen@Charliechen arm-linux]$ arm-none-eabi-gcc --version
arm-none-eabi-gcc (Arch Repository) 14.2.0
Copyright (C) 2024 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

[charliechen@Charliechen arm-linux]$ arm-none-eabi-g++ --version
arm-none-eabi-g++ (Arch Repository) 14.2.0
Copyright (C) 2024 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

如果看到版本号，恭喜你！如果看到"command not found"，那你可能需要先去ARM官网下载工具链，笔者玩的Arch Linux，直接用pacman或者是yay下回来就好了。

> 对了下的是：gcc-arm-none-eabi，不然的话会少标准依赖，您先试试看下arm-none-eabi-gcc，demo拉不通在下标准的EABI

```bash
# 编译C语言代码的标准姿势
arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -Os -c example.c -o example.o

# 编译C++代码的标准姿势，不要exception，也不要rtti，笔者之前就说过了
arm-none-eabi-g++ -mcpu=cortex-m4 -mthumb -Os -fno-exceptions -fno-rtti -c example.cpp -o example.o

# 查看你的代码到底有多"胖"
arm-none-eabi-size example.o

# 如果你想看看编译器到底把你的代码变成了啥样
arm-none-eabi-objdump -d example.o
```

> `-fno-exceptions`和`-fno-rtti`这两个参数是在嵌入式系统中使用C++的"减肥药"。不加这两个，你的固件可能会因为异常处理机制的代码而膨胀到像吃了发酵粉的馒头一样。

------

## 先从点灯开始：GPIO驱动（点个灯而已，有多难？）

咱们第一个事情，是先将之前的内容落到实地，先看看：不同的语言，不同的编程范式，咱们的代码看起来怎么样，实际上的表现又是如何。

### 任务简介

我们要实现一个GPIO驱动来控制LED。这是嵌入式世界的"Hello World"，就像学编程时打印"Hello World"一样经典。功能包括：

- 开灯/关灯（额。。。）
- 切换状态
- PWM调光（装个逼）

#### C语言版本——朴实无华

```c
// gpio_driver.c
#include <stdint.h>
#include <stdbool.h>

// 硬件寄存器定义（这是在和硬件对话的门牌号）
#define GPIO_BASE 0x40020000
#define GPIO_ODR  (*(volatile uint32_t*)(GPIO_BASE + 0x14))
#define GPIO_BSRR (*(volatile uint32_t*)(GPIO_BASE + 0x18))

// GPIO句柄结构体（把状态打包带走）
typedef struct {
    uint8_t pin;
    bool state;
    uint8_t pwm_duty;  // 0-100，就像电灯的亮度旋钮
} GPIO_Handle;

// 初始化GPIO（给我们的LED安个家）
void gpio_init(GPIO_Handle* handle, uint8_t pin) {
    handle->pin = pin;
    handle->state = false;
    handle->pwm_duty = 0;
}

// 设置输出状态（开灯关灯就靠它了）
void gpio_write(GPIO_Handle* handle, bool value) {
    if (value) {
        GPIO_BSRR = (1 << handle->pin);  // 原子操作，不怕中断捣乱
    } else {
        GPIO_BSRR = (1 << (handle->pin + 16));  // 高16位是复位位
    }
    handle->state = value;
}

// 切换状态（懒得记住当前是开还是关？用这个！）
void gpio_toggle(GPIO_Handle* handle) {
    gpio_write(handle, !handle->state);
}

// 设置PWM占空比（让LED可以调亮度）
void gpio_set_pwm(GPIO_Handle* handle, uint8_t duty) {
    if (duty > 100) duty = 100;  // 防止有人手滑输入101
    handle->pwm_duty = duty;
}

// 获取当前状态（查看灯现在到底是开还是关）
bool gpio_read(GPIO_Handle* handle) {
    return handle->state;
}

// 使用示例（三行代码搞定一个LED）
void example_c(void) {
    GPIO_Handle led;
    gpio_init(&led, 5);  // 用GPIO 5号引脚
    
    gpio_write(&led, true);   // 开灯
    gpio_toggle(&led);        // 切换（现在是关）
    gpio_set_pwm(&led, 75);   // 设置75%亮度
}
```

这是笔者的C语言编程风格，当然一些朋友似乎不太喜欢结构体。嗯，笔者还是推介采用结构体，但是不要传它本身触发拷贝，而是传递指针指向这个对象。



#### C++版本——OOP

```cpp
// gpio_driver.hpp
#include <cstdint>

class GPIO {
private:
    // 硬件寄存器定义（藏在private里，外人别乱碰）
    static constexpr uint32_t GPIO_BASE = 0x40020000;
    static volatile uint32_t& GPIO_ODR() {
        return *reinterpret_cast<volatile uint32_t*>(GPIO_BASE + 0x14);
    }
    static volatile uint32_t& GPIO_BSRR() {
        return *reinterpret_cast<volatile uint32_t*>(GPIO_BASE + 0x18);
    }
    
    uint8_t pin_;
    bool state_;
    uint8_t pwm_duty_;

public:
    // 构造函数（一出生就知道自己是谁）
    explicit GPIO(uint8_t pin) : pin_(pin), state_(false), pwm_duty_(0) {}
    
    // 禁用拷贝（硬件资源不能克隆，你能复制一个LED吗？）
    GPIO(const GPIO&) = delete;
    GPIO& operator=(const GPIO&) = delete;
    
    // 写入状态
    void write(bool value) {
        if (value) {
            GPIO_BSRR() = (1U << pin_);
        } else {
            GPIO_BSRR() = (1U << (pin_ + 16));
        }
        state_ = value;
    }
    
    // 切换状态
    void toggle() {
        write(!state_);
    }
    
    // 设置PWM占空比
    void setPWM(uint8_t duty) {
        pwm_duty_ = (duty > 100) ? 100 : duty;
    }
    
    // 读取状态
    bool read() const {
        return state_;
    }
    
    // 运算符重载：让代码看起来像在和LED聊天
    GPIO& operator=(bool value) {
        write(value);
        return *this;
    }
    
    operator bool() const {
        return read();
    }
};

// 使用示例（看起来更像是在"对话"而不是"操作"）
void example_cpp() {
    GPIO led(5);  // 创建一个GPIO对象，它自己知道初始化
    
    led.write(true);
    led.toggle();
    led.setPWM(75);
    
    // 或者使用更直观的语法（就像在说"led你给我开！"）
    led = true;
    if (led) {  // 可以直接当bool用！
        led = false;
    }
}
```

C++中的一个经典的使用，就是采用OOP面对对象的编程思路进行编程。

当然一些朋友会抬杠——谁告诉你，C++是一个OOP语言的？它也是泛型编程语言。也对，我没意见，笔者自己的GPIO库就是用模板写的，不过这里，我们先考虑OOP。

### 战况分析：真的差很多吗？

先不评价，先看看差异如何！

我们将上述C代码保存为demo.c，然后使用的完整编译指令如下：

```bash
arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -Os -c demo.c -o demo_c.o
```

哈？你说你都是IDE直接单点的？好，咱们就来讲讲这在做什么

------

#### `arm-none-eabi-gcc`

指定使用 **ARM 裸机交叉编译器**：

- `arm`：目标架构为 ARM
- `none`：无操作系统（bare-metal）
- `eabi`：嵌入式 ABI

生成的代码 **不能运行在 Linux / Windows**，而是用于 MCU Flash。

------

#### `-mcpu=cortex-m4`

指定**目标 CPU 内核型号**：

- 生成 **针对 Cortex-M4 的指令**
- 启用 M4 特有特性（如 DSP 指令）
- 确保指令集与实际 MCU 完全匹配

当然，如果你说你想试着测一下M1的，也彳亍，换成cortex-m1，都可以试一试。

------

#### `-mthumb`

强制使用 **Thumb 指令集**：

- Cortex-M 系列 **只支持 Thumb**
- 指令更紧凑，代码密度更高
- 是 M 系列的“默认工作模式”

对 Cortex-M 来说，这是**必选项而不是优化项**。

------

#### `-Os`

**以最小代码体积为目标的优化等级**：

- 优先减少 Flash 占用
- 在 `-O2` / `-O3` 的基础上，刻意避免代码膨胀
- 是嵌入式中**最常用、最稳妥**的优化等级

------

#### `-c`：**只编译，不链接**：

- 输入：`demo.c`
- 输出：`demo_c.o`
- 不生成可执行文件

- `.o` 才能用于 `arm-none-eabi-size`
- 可以精确评估“某个源文件本身”的代码体积

------

#### `-o demo_c.o`

指定输出文件名：

```text
demo.c  →  demo_c.o
```

避免使用默认的 `demo.o`，在做 **多语言 / 多版本对比实验**时尤其清晰。

------

### 让我们看看战果

| 实现方式 | text (代码段) | data | bss  | 总计    |
| -------- | ------------- | ---- | ---- | ------- |
| C版本    | 96 bytes      | 0    | 0    | 96      |
| C++版本  | 24 bytes      | 0    | 0    | 24      |
| 差异     | **-72 bytes** | 0    | 0    | **-72** |

**惊不惊喜？意不意外？**

C++版本反而**少了72个字节**，代码量减少了75%！这点减少换来的是：

- ✅ 更好的封装性（私有成员不会被乱改）
- ✅ 自动初始化（不会忘记调用init）
- ✅ 类型安全（不会传错指针）
- ✅ 更直观的语法（`led = true`比`gpio_write(&led, true)`舒服多了）

**关键发现**：C++的内联优化让整个`example_cpp`函数只有24字节，比C版本的多个函数加起来还小！编译器把所有操作都优化成了直接的寄存器操作。

### 汇编级别的真相

不信的话，我们来看看编译器生成的汇编代码（这是编译器的"透视眼"）：

**C版本的example_c（96字节，包含多个函数调用）：**

```assembly
example_c:
  push    {r0, r1, r2, lr}
  movs    r3, #5
  strb.w  r3, [sp, #4]     ; 初始化pin
  ldr     r3, [pc, #20]
  movs    r2, #32
  str     r2, [r3, #24]    ; GPIO操作
  add     r0, sp, #4
  movs    r3, #1
  strb.w  r3, [sp, #5]     ; 设置state
  bl      gpio_toggle       ; 函数调用
  add     sp, #12
  ldr.w   pc, [sp], #4
```

**C++版本的example_cpp（仅24字节，全部内联）：**

```assembly
example_cpp:
  ldr     r3, [pc, #16]
  movs    r1, #32
  mov.w   r2, #2097152     ; 直接计算bit mask
  str     r1, [r3, #24]    ; GPIO操作1
  str     r2, [r3, #24]    ; GPIO操作2
  str     r1, [r3, #24]    ; GPIO操作3
  str     r2, [r3, #24]    ; GPIO操作4
  bx      lr
  nop
```

**看到了吗？C++版本更简洁高效！**

编译器把C++的类方法全部内联，消除了函数调用开销，直接生成最优化的寄存器操作。而C版本由于函数分离，需要额外的栈操作和函数跳转。

**结论**：C++的封装是"零开销抽象"——不仅零开销，在很多情况下反而更高效！这不是营销口号，是真的！

------

## 第二回合：环形缓冲区（UART的好帮手）

### 任务简介

环形缓冲区（Ring Buffer）是嵌入式系统的"瑞士军刀"。当UART数据像洪水一样涌来时，你需要一个地方暂存它们。这就是环形缓冲区的用武之地——一个首尾相连、永不浪费的数据容器。

想象一个寿司转台，盘子绕着圈转，你放盘子（写入），别人拿盘子（读取），只要盘子没满，转台就一直转。

#### C语言版本——那就朴实

```c
// ring_buffer.c
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#define BUFFER_SIZE 64  // 64字节，不大不小刚刚好

typedef struct {
    uint8_t buffer[BUFFER_SIZE];
    volatile uint16_t head;   // 写指针（放盘子的位置）
    volatile uint16_t tail;   // 读指针（拿盘子的位置）
    volatile uint16_t count;  // 当前有多少盘子
} RingBuffer;

// 初始化（把转台清空）
void rb_init(RingBuffer* rb) {
    rb->head = 0;
    rb->tail = 0;
    rb->count = 0;
}

// 写入一个字节（放一个盘子上台）
bool rb_put(RingBuffer* rb, uint8_t data) {
    if (rb->count >= BUFFER_SIZE) {
        return false; // 转台满了，请稍后再试
    }
    
    rb->buffer[rb->head] = data;
    rb->head = (rb->head + 1) % BUFFER_SIZE;  // 绕圈圈
    rb->count++;
    return true;
}

// 读取一个字节（拿一个盘子）
bool rb_get(RingBuffer* rb, uint8_t* data) {
    if (rb->count == 0) {
        return false; // 转台空了，没东西可拿
    }
    
    *data = rb->buffer[rb->tail];
    rb->tail = (rb->tail + 1) % BUFFER_SIZE;  // 绕圈圈
    rb->count--;
    return true;
}

// 查询还有多少数据（还有多少盘子）
uint16_t rb_available(RingBuffer* rb) {
    return rb->count;
}

// 查询还有多少空间（还能放多少盘子）
uint16_t rb_free_space(RingBuffer* rb) {
    return BUFFER_SIZE - rb->count;
}

// 清空缓冲区（把转台上的盘子全部拿走）
void rb_clear(RingBuffer* rb) {
    rb->head = 0;
    rb->tail = 0;
    rb->count = 0;
}

// 使用示例
void example_c_rb(void) {
    RingBuffer uart_rx;
    rb_init(&uart_rx);
    
    // 写入数据（发送"Hello"）
    const char* msg = "Hello";
    for (int i = 0; msg[i]; i++) {
        rb_put(&uart_rx, msg[i]);
    }
    
    // 读取数据（接收并处理）
    uint8_t byte;
    while (rb_get(&uart_rx, &byte)) {
        // 处理每个字节
    }
}
```

#### C++版本——那就泛型

好，这里我们就写泛型——泛型有个毛病就是代码膨胀的问题

```cpp
// ring_buffer.hpp
#include <cstdint>
#include <cstring>
#include <array>

// 模板参数：想要多大的转台，你说了算！
template<size_t Size = 64>
class RingBuffer {
private:
    std::array<uint8_t, Size> buffer_;  // 用std::array而不是C数组
    volatile uint16_t head_{0};
    volatile uint16_t tail_{0};
    volatile uint16_t count_{0};

public:
    // 构造函数（转台出厂就是干净的）
    RingBuffer() = default;
    
    // 写入一个字节
    bool put(uint8_t data) {
        if (count_ >= Size) {
            return false;
        }
        
        buffer_[head_] = data;
        head_ = (head_ + 1) % Size;
        count_++;
        return true;
    }
    
    // 读取一个字节（注意：这里用引用返回，避免指针）
    bool get(uint8_t& data) {
        if (count_ == 0) {
            return false;
        }
        
        data = buffer_[tail_];
        tail_ = (tail_ + 1) % Size;
        count_--;
        return true;
    }
    
    // 批量写入（一次放多个盘子）
    size_t write(const uint8_t* data, size_t len) {
        size_t written = 0;
        for (size_t i = 0; i < len && put(data[i]); i++) {
            written++;
        }
        return written;
    }
    
    // 批量读取（一次拿多个盘子）
    size_t read(uint8_t* data, size_t len) {
        size_t read_count = 0;
        for (size_t i = 0; i < len && get(data[i]); i++) {
            read_count++;
        }
        return read_count;
    }
    
    // 查询方法（[[nodiscard]]告诉编译器：别忽略返回值！）
    [[nodiscard]] uint16_t available() const { return count_; }
    [[nodiscard]] uint16_t freeSpace() const { return Size - count_; }
    [[nodiscard]] bool isEmpty() const { return count_ == 0; }
    [[nodiscard]] bool isFull() const { return count_ >= Size; }
    
    // 清空
    void clear() {
        head_ = 0;
        tail_ = 0;
        count_ = 0;
    }
    
    // 获取容量（编译期常量，不占运行时间）
    static constexpr size_t capacity() { return Size; }
};

// 使用示例（注意模板参数可以在编译期指定大小）
void example_cpp_rb() {
    RingBuffer<64> uart_rx;  // 64字节的缓冲区
    
    // 写入数据
    const char* msg = "Hello";
    uart_rx.write(reinterpret_cast<const uint8_t*>(msg), strlen(msg));
    
    // 读取数据
    uint8_t byte;
    while (uart_rx.get(byte)) {
        // 处理每个字节
    }
    
    // 或者批量读取
    uint8_t buffer[32];
    size_t n = uart_rx.read(buffer, sizeof(buffer));
}
```

------

### 第一段：环形缓冲区实现对比

让我们看看战果：

| 实现方式 | text (代码段) | data | bss  | 总计    |
| -------- | ------------- | ---- | ---- | ------- |
| C版本    | 218 bytes     | 0    | 0    | 218     |
| C++版本  | 150 bytes     | 0    | 0    | 150     |
| 差异     | **-68 bytes** | 0    | 0    | **-68** |

**惊不惊喜？意不意外？**

C++版本反而**少了68个字节**，代码量减少了31%！这还是在实现了完整环形缓冲区功能的情况下。这点减少换来的是：

- ✅ 更好的封装性（内部索引不会被外部修改）
- ✅ 自动构造函数初始化（不会忘记调用init）
- ✅ 类型安全（不会传错指针）
- ✅ 更直观的方法调用（`rb.put(data)`比`rb_put(&rb, data)`舒服多了）

**关键发现**：C++通过内联优化消除了函数调用开销，同时编译器能更好地优化类方法。C版本需要多个独立函数（`rb_init`, `rb_put`, `rb_get`, `rb_available`, `rb_free_space`, `rb_clear`），而C++版本通过智能内联将这些操作融合得更紧凑。

### 汇编级别的真相

不信的话，我们来看看编译器生成的汇编代码：

**C版本的example_c_rb（依赖多个函数）：**

```assembly
example_c_rb:
  push    {lr}
  sub     sp, #84
  movs    r3, #0
  ldr     r2, [pc, #44]
  strh.w  r3, [sp, #72]    ; 初始化
  strh.w  r3, [sp, #74]
  strh.w  r3, [sp, #76]
  ; ... 循环写入
  bl      rb_put            ; 函数调用开销
  ; ... 循环读取
  bl      rb_get            ; 函数调用开销
  add     sp, #84
  ldr.w   pc, [sp], #4
```

**C++版本的example_cpp_rb（完全内联）：**

```assembly
example_cpp_rb:
  sub     sp, #72
  movs    r3, #0
  strh.w  r3, [sp, #64]    ; 内联初始化
  movs    r2, #5
  strh.w  r3, [sp, #66]
  strh.w  r3, [sp, #68]
  ; ... 直接操作，无函数调用
  ldrh.w  r3, [sp, #68]
  adds    r3, #1
  strh.w  r3, [sp, #68]    ; 内联的put操作
  ; ... 继续内联操作
  add     sp, #72
  bx      lr
```

**看到了吗？C++版本消除了所有函数调用！**

编译器把所有方法内联到一起，减少了栈操作、函数跳转和寄存器保存。C版本因为函数分离，每次`rb_put`和`rb_get`都需要额外的`bl`指令和栈帧设置。

------

## 第三回合：状态机（按键消抖的艺术）

### 任务简介

按键消抖是嵌入式工程师的"必修课"。机械按键在按下和释放时会产生抖动（就像弹簧来回震动），如果不处理，一次按键可能被识别成十几次。

我们要实现一个状态机来：

- 检测按键按下
- 检测按键释放
- 检测长按（按住1秒以上）
- 消抖（50ms内的抖动忽略）

### C语言版本：经典状态机

```c
// button_fsm.c
#include <stdint.h>
#include <stdbool.h>

// 按键状态（状态机的"房间"）
typedef enum {
    BTN_STATE_IDLE,        // 闲置状态（没人按）
    BTN_STATE_PRESSED,     // 按下状态（刚按下）
    BTN_STATE_RELEASED,    // 释放状态（刚松开）
    BTN_STATE_LONG_PRESS   // 长按状态（按了很久）
} ButtonState;

// 按键事件（状态机的"输出"）
typedef enum {
    BTN_EVENT_NONE,
    BTN_EVENT_PRESS,       // 检测到短按
    BTN_EVENT_RELEASE,     // 检测到释放
    BTN_EVENT_LONG_PRESS   // 检测到长按
} ButtonEvent;

// 按键状态机结构体
typedef struct {
    ButtonState state;
    uint32_t timestamp;         // 时间戳（记录何时进入当前状态）
    uint8_t pin;                // GPIO引脚
    bool last_reading;          // 上次读数
    uint16_t debounce_time;     // 消抖时间（ms）
    uint16_t long_press_time;   // 长按时间（ms）
} ButtonFSM;

// 初始化
void btn_init(ButtonFSM* btn, uint8_t pin) {
    btn->state = BTN_STATE_IDLE;
    btn->timestamp = 0;
    btn->pin = pin;
    btn->last_reading = false;
    btn->debounce_time = 50;     // 50ms消抖
    btn->long_press_time = 1000; // 1s长按
}

// 硬件接口（假设这些函数已经实现）
extern bool hw_read_pin(uint8_t pin);
extern uint32_t hw_get_tick(void);

// 状态机更新（在主循环中不断调用）
ButtonEvent btn_update(ButtonFSM* btn) {
    bool reading = hw_read_pin(btn->pin);
    uint32_t now = hw_get_tick();
    ButtonEvent event = BTN_EVENT_NONE;
    
    // 状态机核心：根据当前状态和输入决定下一步
    switch (btn->state) {
        case BTN_STATE_IDLE:
            // 闲置状态：检测按下
            if (reading && !btn->last_reading) {
                btn->timestamp = now;
                btn->state = BTN_STATE_PRESSED;
            }
            break;
            
        case BTN_STATE_PRESSED:
            // 按下状态：等待释放或长按
            if (!reading) {
                // 松开了
                if ((now - btn->timestamp) >= btn->debounce_time) {
                    event = BTN_EVENT_PRESS;  // 确认是有效按下
                    btn->state = BTN_STATE_RELEASED;
                    btn->timestamp = now;
                } else {
                    btn->state = BTN_STATE_IDLE;  // 抖动，忽略
                }
            } else if ((now - btn->timestamp) >= btn->long_press_time) {
                // 按太久了！
                event = BTN_EVENT_LONG_PRESS;
                btn->state = BTN_STATE_LONG_PRESS;
            }
            break;
            
        case BTN_STATE_RELEASED:
            // 释放状态：确认释放
            if ((now - btn->timestamp) >= btn->debounce_time) {
                if (!reading) {
                    event = BTN_EVENT_RELEASE;
                    btn->state = BTN_STATE_IDLE;
                } else {
                    btn->state = BTN_STATE_PRESSED;  // 又按下了？
                    btn->timestamp = now;
                }
            }
            break;
            
        case BTN_STATE_LONG_PRESS:
            // 长按状态：等待释放
            if (!reading) {
                btn->state = BTN_STATE_IDLE;
            }
            break;
    }
    
    btn->last_reading = reading;
    return event;
}

// 使用示例
void example_c_button(void) {
    ButtonFSM power_button;
    btn_init(&power_button, 3);  // 使用GPIO 3
    
    // 在主循环中调用
    while (1) {
        ButtonEvent evt = btn_update(&power_button);
        switch (evt) {
            case BTN_EVENT_PRESS:
                // 短按：切换开关
                break;
            case BTN_EVENT_LONG_PRESS:
                // 长按：进入设置菜单
                break;
            case BTN_EVENT_RELEASE:
                // 释放：什么都不做
                break;
            default:
                break;
        }
    }
}
```

### C++版本：面向对象的状态机

```cpp
// button_fsm.hpp
#include <cstdint>
#include <functional>

// 硬件接口（假设这些函数已经实现）
extern bool hw_read_pin(uint8_t pin);
extern uint32_t hw_get_tick(void);

class Button {
public:
    // 事件类型（用enum class更安全）
    enum class Event {
        None,
        Press,
        Release,
        LongPress
    };
    
    // 回调函数类型（可以是lambda、函数指针等）
    using EventCallback = std::function<void(Event)>;

private:
    // 内部状态（外人看不到）
    enum class State {
        Idle,
        Pressed,
        Released,
        LongPress
    };
    
    State state_{State::Idle};
    uint32_t timestamp_{0};
    uint8_t pin_;
    bool last_reading_{false};
    uint16_t debounce_time_{50};
    uint16_t long_press_time_{1000};
    EventCallback callback_;  // 事件回调
    
    // 硬件接口（封装在内部）
    bool readPin() const {
        return hw_read_pin(pin_);
    }
    
    uint32_t getTick() const {
        return hw_get_tick();
    }
    
    // 通知事件（如果有回调的话）
    void notifyEvent(Event event) {
        if (callback_ && event != Event::None) {
            callback_(event);
        }
    }

public:
    // 构造函数（可以自定义消抖和长按时间）
    explicit Button(uint8_t pin, 
                   uint16_t debounce_ms = 50,
                   uint16_t long_press_ms = 1000)
        : pin_(pin)
        , debounce_time_(debounce_ms)
        , long_press_time_(long_press_ms) {}
    
    // 设置回调函数（支持lambda表达式）
    void setCallback(EventCallback callback) {
        callback_ = callback;
    }
    
    // 状态机更新
    Event update() {
        bool reading = readPin();
        uint32_t now = getTick();
        Event event = Event::None;
        
        switch (state_) {
            case State::Idle:
                if (reading && !last_reading_) {
                    timestamp_ = now;
                    state_ = State::Pressed;
                }
                break;
                
            case State::Pressed:
                if (!reading) {
                    if ((now - timestamp_) >= debounce_time_) {
                        event = Event::Press;
                        state_ = State::Released;
                        timestamp_ = now;
                    } else {
                        state_ = State::Idle;
                    }
                } else if ((now - timestamp_) >= long_press_time_) {
                    event = Event::LongPress;
                    state_ = State::LongPress;
                }
                break;
                
            case State::Released:
                if ((now - timestamp_) >= debounce_time_) {
                    if (!reading) {
                        event = Event::Release;
                        state_ = State::Idle;
                    } else {
                        state_ = State::Pressed;
                        timestamp_ = now;
                    }
                }
                break;
                
            case State::LongPress:
                if (!reading) {
                    state_ = State::Idle;
                }
                break;
        }
        
        last_reading_ = reading;
        notifyEvent(event);  // 自动通知回调
        return event;
    }
    
    // 查询方法
    [[nodiscard]] bool isPressed() const {
        return state_ == State::Pressed || state_ == State::LongPress;
    }
};

// 使用示例（看看C++的回调有多爽）
void example_cpp_button() {
    Button power_button(3);
    
    // 使用lambda表达式作为回调
    power_button.setCallback([](Button::Event evt) {
        switch (evt) {
            case Button::Event::Press:
                // 短按：切换开关
                break;
            case Button::Event::LongPress:
                // 长按：进入设置菜单
                break;
            case Button::Event::Release:
                // 释放：什么都不做
                break;
            default:
                break;
        }
    });
    
    // 在主循环中调用
    while (true) {
        power_button.update();  // 自动调用回调
    }
}

// 如果不想用std::function（它有点重），可以用函数指针版本
class ButtonLite {
public:
    enum class Event { None, Press, Release, LongPress };
    using EventCallback = void (*)(Event);  // 函数指针，更轻量
    
    // ... 其他实现类似，但用函数指针代替std::function
};
```

### 战况分析：std::function的代价

| 实现方式                | text (代码段)  | data | bss  | 总计     |
| ----------------------- | -------------- | ---- | ---- | -------- |
| C版本                   | 172 bytes      | 0    | 0    | 172      |
| C++版本 (std::function) | 306 bytes      | 0    | 0    | 306      |
| 差异                    | **+134 bytes** | 0    | 0    | **+134** |

**这次差异明显了！**C++版本增加了**78%的代码量**，这134字节的代价来自于这些地方：

-  `std::function`的类型擦除机制（需要虚函数表）
-  lambda捕获的额外开销
- 动态多态的运行时支持代码

所以，这个事情是想跟你说——咱们的C++不是所有抽象的都是0开销的，以**std::function为例子：它带来了显著的代码膨胀（78%增长）**，而且：**lambda捕获是存在隐藏成本的，因为每个lambda都需要额外的存储和管理代码，这一点熟悉Lambda的朋友应该知晓——他会生成一个带有`operator()`调用，存储每一个捕获对象的结构体**：

这里代替方案也很简单：

```cpp
// 方案1：函数指针（接近C的开销）
using callback_t = void (*)(int);
void set_callback(callback_t cb);

// 方案2：模板回调（零开销，编译期展开）
template<typename Callback>
void process(Callback cb) {
    cb(42);  // 完全内联
}

// 方案3：直接调用（最优）
void process() {
    handle_event(42);
}
```

## 说话!

#### 代码大小对比表

我们回顾下：

**案例一：GPIO操作封装**

在GPIO操作场景中，C++类封装展现出令人惊讶的优势。C版本需要96字节来实现gpio_init、gpio_write、gpio_toggle等多个函数，而C++版本通过编译器的内联优化，将整个操作序列压缩到仅24字节，代码量减少了75%。这种巨大的差异来自于编译器能够将C++的成员函数调用完全内联，消除了函数调用开销和栈帧管理。

**案例二：环形缓冲区实现**

环形缓冲区的实现进一步验证了C++的优势。C版本需要实现rb_init、rb_put、rb_get、rb_available、rb_free_space、rb_clear等六个独立函数，总计218字节。而C++版本通过类封装和方法内联，将代码量减少到150字节，节省了31%的空间。关键在于编译器能够看到完整的调用链，从而进行更激进的优化。

**案例三：std::function的警示**

并非所有C++特性都适合嵌入式开发。当使用std::function实现回调时，代码从C版本的172字节膨胀到306字节，增加了78%。这是因为std::function需要类型擦除机制、虚函数表支持以及lambda捕获的管理代码。这个案例提醒我们，在资源受限的环境中，必须谨慎选择使用的C++特性。

| 特性             | 代码增长     | 建议                             |
| ---------------- | ------------ | -------------------------------- |
| 类封装（基础）   | -75% 到 -31% | 强烈推荐（实测反而更小）         |
| 类封装（带模板） | +4%          | 强烈推荐（几乎零开销）           |
| 虚函数           | +20-40%      | 谨慎使用（考虑CRTP替代）         |
| 异常处理         | +50-100%     | 禁用（-fno-exceptions）          |
| RTTI             | +30-50%      | 禁用（-fno-rtti）                |
| std::function    | +78%         | 谨慎使用（用函数指针或模板替代） |
| 模板（泛型容器） | +4%          | 强烈推荐（编译期优化）           |

### 性能对比表

基于汇编级别的周期计数分析：

| 类别             | C实现        | C++实现      | 差异    |
| ---------------- | ------------ | ------------ | ------- |
| GPIO单次操作     | 8-10 cycles  | 8-10 cycles  | 0%      |
| 缓冲区读写       | 12-15 cycles | 12-15 cycles | 0%      |
| 内联后的完整操作 | 需要函数调用 | 完全内联     | C++更快 |

**关键发现**：在启用优化的情况下，C++的零开销抽象不是营销口号，而是可验证的事实。编译器生成的汇编代码显示，C++的类方法和C的函数在单个操作层面完全相同，而在复杂操作场景中，C++由于内联优化甚至更快。

------

## 最佳实践：如何在嵌入式系统中优雅地使用C++

### 一、编译器选项（减肥配置）

嵌入式C++开发的黄金编译器配置如下：

```bash
# 基础优化
-Os                        # 优化代码大小而非速度
-mcpu=cortex-m4           # 指定目标处理器
-mthumb                   # 使用Thumb指令集（代码更紧凑）

# C++特性控制（关键）
-fno-exceptions           # 禁用异常处理（节省50-100%代码）
-fno-rtti                 # 禁用运行时类型信息（节省30-50%）
-fno-threadsafe-statics   # 禁用线程安全的静态初始化

# 代码段优化
-ffunction-sections       # 每个函数放入独立段
-fdata-sections          # 每个数据对象放入独立段
-Wl,--gc-sections        # 链接时删除未使用的段

# 进一步优化
-flto                    # 链接时优化（Link Time Optimization）
-fno-use-cxa-atexit     # 禁用全局析构函数注册
```

这套配置能够确保C++代码在嵌入式环境中保持高效紧凑。实测显示，正确配置的C++代码可以达到与C相当甚至更小的体积。

### 二、推荐使用的C++特性

以下特性经过实测验证，在嵌入式系统中表现优秀：

**类和对象（强烈推荐）**

类封装是C++的核心优势，能够将硬件资源抽象为对象。实测显示，简单的类封装不仅不会增加代码量，反而因为编译器优化而减少代码。例如，将GPIO寄存器封装为类，可以提供类型安全和更好的接口，同时保持零开销。

**构造和析构函数（强烈推荐）**

构造函数提供自动初始化，析构函数实现RAII模式，这是C++最强大的资源管理机制。在嵌入式系统中，可以用析构函数自动关闭外设、释放资源，避免资源泄漏。编译器通常能将简单的构造函数完全内联。

**模板（强烈推荐）**

模板提供编译期的代码生成，完全没有运行时开销。环形缓冲区的测试显示，模板版本仅增加4%的代码量，却提供了类型安全和大小参数化。相比C的宏，模板更安全、更易调试。

**constexpr（强烈推荐）**

constexpr函数在编译期计算，结果直接嵌入代码。可以用于计算配置参数、查找表生成等场景，完全零运行时开销。

**引用和inline函数（强烈推荐）**

引用避免了不必要的拷贝，inline函数消除函数调用开销。在嵌入式系统中，合理使用引用可以显著提升性能，特别是在传递结构体时。

**运算符重载（适度推荐）**

运算符重载可以让代码更直观，例如用`gpio = true`代替`gpio_write(&gpio, 1)`。只要不滥用，运算符重载不会带来额外开销。

### 三、谨慎使用的C++特性

以下特性有一定开销，需要根据实际情况权衡：

**虚函数（谨慎使用）**

虚函数引入vtable，每个对象增加4字节指针开销，每次调用需要间接跳转。如果确实需要多态，考虑使用CRTP（Curiously Recurring Template Pattern）实现编译期多态，可以避免运行时开销。

**std::function（谨慎使用）**

实测显示std::function会导致78%的代码膨胀。如果需要回调机制，优先考虑函数指针（与C相同开销）或模板回调（零开销）。只有在需要捕获状态的lambda时，才考虑std::function。

**动态内存分配（谨慎使用）**

new和delete在嵌入式系统中可能导致内存碎片。建议使用placement new配合静态内存池，或者使用栈上对象。如果必须使用动态内存，考虑自定义分配器。

**STL容器（谨慎使用）**

标准库容器如std::vector、std::map的实现可能较大。建议先测试代码大小，或使用专门为嵌入式优化的容器库（如EASTL）。对于简单场景，手写固定大小的容器可能更合适。

### 四、禁止使用的C++特性

以下特性在嵌入式系统中应当完全避免：

**异常处理（禁止）**

异常处理机制会使代码膨胀50-100%，且引入不可预测的执行路径。嵌入式系统需要确定性的行为，应使用错误码或断言代替异常。务必添加-fno-exceptions编译选项。

**RTTI（禁止）**

运行时类型信息会增加30-50%的代码，且在嵌入式系统中很少需要。使用-fno-rtti禁用。如果需要类型识别，可以手动实现简单的类型标记系统。

**iostream库（禁止）**

std::cout和std::cin会引入巨大的代码（几十KB），远超嵌入式系统的承受能力。使用传统的printf/scanf或专门的嵌入式日志库。

**多重继承（禁止）**

多重继承增加复杂度和代码量，且可能导致diamond问题。在嵌入式系统中，单一继承或组合模式就足够了。

------

## 实战建议：何时用C，何时用C++？

### 选择C的场景

**极度资源受限的环境**

当目标硬件Flash小于8KB、RAM小于1KB时，C是更安全的选择。这类系统通常是简单的传感器节点或控制器，不需要复杂的抽象。

**团队技术栈限制**

如果团队成员不熟悉C++，或者项目时间紧张，强行使用C++可能得不偿失。C的学习曲线更平缓，更容易掌握。

**纯C代码库集成**

当需要集成大量现有的C代码库时，使用C可以避免混合编程的麻烦。虽然C++可以调用C代码，但在某些情况下纯C项目更简单。

**工具链支持不足**

某些老旧或专用的编译器对C++支持不完整，可能产生低效的代码。这时C是更可靠的选择。

### 选择C++的场景

**中等以上资源的系统**

当Flash大于16KB、RAM大于2KB时，C++的优势开始显现。这类系统有足够空间容纳C++的抽象机制，同时能从封装和类型安全中受益。

**复杂的状态管理**

实现状态机、协议栈、传感器融合等复杂逻辑时，C++的类封装可以显著降低复杂度。对象可以封装状态和行为，使代码更易维护。

**需要代码复用**

当有多个相似的模块（如多个串口、多个定时器）时，C++模板比C的宏更安全、更易调试。模板提供编译期的类型检查和参数化。

**现代开发实践**

如果团队熟悉现代C++（C++11及以后），能够正确使用智能指针、移动语义、lambda等特性，开发效率会显著提升。

### 混合使用（最佳实践）

许多成功的嵌入式项目采用分层的混合策略：

**底层驱动层：使用C**

直接操作寄存器的底层驱动用C编写，保证稳定性和可移植性。这部分代码通常不复杂，C已经足够。

**中间抽象层：使用C++**

将底层驱动封装为C++类，提供面向对象的接口。例如，将UART驱动封装为SerialPort类，提供更安全、更易用的API。

**应用逻辑层：使用C++**

业务逻辑、状态机、数据处理等用C++实现，利用类、模板、RAII等特性简化代码。

**模块接口：使用extern "C"**

模块之间的接口使用extern "C"声明，确保C和C++模块可以无缝协作。这种方式既保持了灵活性，又避免了名称修饰的问题。



------

## 练习时间：动手试试吧！

### 练习1：实测对比

在你的开发板上实现上述三个示例，测量：

1. Flash占用（用`arm-none-eabi-size`）
2. RAM占用（检查.bss和.data段）
3. 运行时间（用DWT周期计数器）

### 练习2：优化挑战

尝试优化环形缓冲区：

1. 当Size是2的幂时，用位运算替代取模（`% Size` → `& (Size-1)`）
2. 实现零拷贝的`peek()`操作
3. 添加中断安全版本（禁用中断或用原子操作）

### 练习3：设计决策

为以下场景选择C或C++：

1. 简单UART驱动（只收发）→ **你的选择？**
2. 传感器融合算法（卡尔曼滤波）→ **你的选择？**
3. 1ms实时控制循环 → **你的选择？**
4. OTA固件升级模块 → **你的选择？**

### 练习4：代码审查

找出以下C++代码的问题：

```cpp
class Sensor {
    std::vector<int> data;  // 问题1: ?
public:
    virtual void read() {   // 问题2: ?
        throw std::runtime_error("Not implemented"); // 问题3: ?
    }
};
```

**改进版本**：

```cpp
template<size_t MaxSize>
class Sensor {
    std::array<int, MaxSize> data_;
    size_t size_{0};
public:
    [[nodiscard]] bool read() {  // 用bool表示成功/失败
        // 实现...
        return true;
    }
};
```

## 最后的最后

引用Bjarne Stroustrup（C++之父）的话：

> "C++不是一门你必须全部使用的语言，而是一门你可以选择使用的语言。"

在嵌入式系统中，我们要做聪明的选择者，而不是盲目的追随者。用C++的强大特性来提高代码质量，同时避开那些在资源受限环境中不适用的特性。
