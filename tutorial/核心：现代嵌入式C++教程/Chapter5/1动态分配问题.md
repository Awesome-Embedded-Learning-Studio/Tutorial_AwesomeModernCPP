# 动态内存的代价：碎片化与不确定性（内存布局、碎片化与内存对齐）

## 前言

在嵌入式系统中，动态内存看起来方便，但它带来的代价往往被低估——碎片化、时序不确定性、对齐与结构填充问题会悄悄吞噬资源与可靠性。

我们都知道，都是嵌入式了，资源非常有限，内存分配的微小决策会影响稳定性、实时性与功耗。理解动态内存的代价，能让你在设计时避免灾难性错误 —— 或者在不得不使用动态内存时把风险降到最低。

------

## 内存布局快速回顾：静态、堆、栈

开始之前，回顾一下概念：

- **静态区（.data/.bss/.rodata）**：编译期或链接时大小确定，全局变量、常量、只读数据。生命周期与程序相同，碎片化风险几乎为零，但灵活性低。
- **栈（stack）**：函数调用局部变量、自动对象。分配/释放速度非常快（通常是指针增减），规则性强，生命周期由作用域控制。缺点是容量有限、不可跨任务共享、不适合大对象或可变生命周期对象。
- **堆（heap）**：运行时动态分配（`malloc` / `new` / `operator new` 等）。灵活但代价明显：分配和释放时间不确定、会产生碎片、内存布局非线性。

在嵌入式里，首选顺序一般是：栈（若大小允许）→ 静态（可预分配）→ 堆（谨慎使用、最好受控）。

------

## 碎片化：什么、为什么以及如何影响系统

### 内部碎片（Internal fragmentation）

当分配器为满足对齐或最小分配单位而分配比实际请求更大的块，这部分未用空间就是**内部碎片**。例：

- 分配器以 16 字节粒度分配，一个 20 字节对象会占用 32 字节（16×2），多出的 12 字节即内部碎片。
- 小对象频繁分配但分配单位较大，会导致内存利用率下降。

### 外部碎片（External fragmentation）

堆中有许多空闲块，但这些空闲块分散、不连续，无法合并成足够大的连续空间以满足较大分配请求。结果可能出现内存总量足够但无法分配的情况（“可用内存碎片化”）。我们得到的表现是——

- 随运行时间增长，可用大块内存减少，偶发 `new`/`malloc` 失败。
- 系统表现为间歇性崩溃、内存泄漏样症状、长期运行后稳定性下降。
- 实时任务出现长尾延迟（偶发的长时间分配/回收操作）。

------

## 对齐（alignment）与填充（padding）

### 为什么需要对齐

CPU 通常期望某些数据按其自然边界对齐（例如 4 字节对齐、8 字节对齐），否则访问变慢或在某些架构上产生硬件异常。对齐也影响 DMA、外设访问和缓存一致性。

### 结构体填充示例

```cpp
// 假设：sizeof(char)=1, sizeof(int32_t)=4
struct A {
    char c;      // offset 0
    int32_t x;   // 如果按照 4 字节对齐，x 的 offset 通常是 4
};              // sizeof(A) 通常是 8（包括 3 字节填充）
```

`char` 占 1 字节，`int32_t` 需要 4 字节对齐，因此编译器在 `c` 后插入 3 字节填充，结构体总大小对齐到 4 的倍数（这里为 8）。

将大对齐要求的成员放前面可以减少填充：

```cpp
struct B {
    int32_t x;
    char c;
}; // sizeof(B) 通常是 8，但如果有更多小成员，将更紧凑
```

或者使用 `#pragma pack` 或 `__attribute__((packed))` 强制去掉填充，但注意：

- 去掉填充后读取未对齐的成员在某些架构上性能大幅下降或产生硬件异常。
- 仅在明确知道后果且为节省空间必须时使用。

#### 与 DMA / cacheline 的关系

- DMA 要求缓冲区对齐到外设要求（例如 32 字节）。未对齐会导致硬件拒绝或性能严重下降。
- 对齐到 cacheline（通常 32/64 字节）有助于避免伪共享和缓存抖动，尤其在多核或与 DMA 并发访问时重要。

------

## 动态内存的不确定性：时间与可重复性问题

- **分配/释放时间不确定**：通用堆实现存在复杂的数据结构（自由列表、树、位图），导致 `malloc`/`free` 的执行时间不可预测，可能有长尾延迟。
- **并发与锁争用**：多线程环境下堆通常需要锁或线程局部缓存（TLC）；锁争用会影响实时性。
- **不可恢复的碎片化**：对于 C/C++ 的普通堆，碎片化一旦形成，很难在线性时间内恢复，必须通过重启或专门的紧缩策略（通常不现实）来解决。

嵌入式系统尤其敏感：长尾延迟可能导致丢帧、控制超时或安全问题。

------

## 嵌入式常用替代方案与混合策略

所以咋办，下面快速说几种常见的策略：

#### 内存池（Pool / Slab）

- 将内存分成固定大小的块（例如 32B、64B、256B）。分配返回块索引或指针，释放将块放回空闲链表。
- 优点：分配/释放常数时间（O(1)），不会发生外部碎片（只要所有对象大小匹配某个池）。
- 缺点：对不同大小对象需要多个池，内存利用取决于分配粒度，会产生内部碎片。

#### Bump / Arena 分配器（单向分配器）

- 从一个连续缓冲区线性分配，释放通常是一次性（整个 arena 重置）。
- 非常快，且没有碎片；适合生命周期一致的对象（例如一次任务或一次初始化期间的临时对象）。
- 不适合需要任意释放的对象。

#### Slab 分配（Linux 风格）

- 适合缓存相同类型对象（内核对象），可在释放时重用已初始化的对象，减少构造/销毁开销。

#### 对象池 + RAII（C++ 风格）

- 用 `std::unique_ptr<T, Deleter>` 或自定义智能指针与内存池结合，保证异常安全与自动释放。



