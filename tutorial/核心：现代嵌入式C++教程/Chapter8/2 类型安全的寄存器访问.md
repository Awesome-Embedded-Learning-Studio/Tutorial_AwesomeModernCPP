# 嵌入式C++教程——类型安全的寄存器访问

写寄存器操作时我们常见的开胃菜是这样的单行悲歌：

```cpp
*(volatile uint32_t*)0x40001000 |= (1 << 3);
```

它的优点是短小精悍；缺点是你明天看不懂、编译器看得懂但不尽人意、同时还可能踩到未定义行为的地雷。

用**编译期常量 + 模板 + 强类型枚举**把寄存器地址、位域与操作封装起来；同时用**constexpr mask / static_assert**在编译期捕捉错误。务必保留 `volatile`（告诉编译器不要优化掉硬件访问）并在需要时使用内存屏障（barrier）保证可见性与顺序性。

------

## 一个简洁的类型安全寄存器封装

下面给出一个小而完整的实现样板，既能读写寄存器，也能安全地读写字段（field）并支持用户自定义的强枚举类型。

```cpp
// reg.hpp
#pragma once
#include <cstdint>
#include <type_traits>

template<typename RegT, std::uintptr_t addr>
struct mmio_reg {
    static_assert(std::is_integral_v<RegT>, "RegT must be integral");
    using value_type = RegT;
    static constexpr std::uintptr_t address = addr;

    // 直接读取
    static inline RegT read() noexcept {
        volatile RegT* p = reinterpret_cast<volatile RegT*>(address);
        RegT v = *p;
        compiler_barrier();
        return v;
    }

    // 直接写入
    static inline void write(RegT v) noexcept {
        volatile RegT* p = reinterpret_cast<volatile RegT*>(address);
        *p = v;
        compiler_barrier();
    }

    // 按位设置（OR）
    static inline void set_bits(RegT mask) noexcept {
        write(read() | mask);
    }

    // 按位清除（AND ~mask）
    static inline void clear_bits(RegT mask) noexcept {
        write(read() & ~mask);
    }

    // 通用修改器：读取 -> 修改 -> 写回，lambda 接受并返回 RegT
    template<typename F>
    static inline void modify(F f) noexcept {
        RegT val = read();
        val = f(val);
        write(val);
    }

private:
    static inline void compiler_barrier() noexcept {
        // 强制编译器不重排序访问（实现可按目标平台替换为更强的指令）
        asm volatile ("" ::: "memory");
    }
};

// 字段访问（Offset: 起始位，Width: 位宽）
template<typename Reg, unsigned Offset, unsigned Width>
struct reg_field {
    static_assert(Width > 0 && Width <= (8 * sizeof(typename Reg::value_type)), "bad width");
    using reg_t = Reg;
    using value_type = typename Reg::value_type;
    static constexpr unsigned offset = Offset;
    static constexpr unsigned width  = Width;
    static constexpr value_type mask = ((static_cast<value_type>(1) << width) - 1) << offset;

    // 取值（未右移）
    static inline value_type read_raw() noexcept {
        return (reg_t::read() & mask) >> offset;
    }

    // 写入原始值（value 必须在域范围内）
    static inline void write_raw(value_type value) noexcept {
        value = (value << offset) & mask;
        reg_t::modify([&](value_type v){ return (v & ~mask) | value; });
    }

    // 强类型枚举友好版：若传入枚举则会静态检查与转换
    template<typename E>
    static inline void write(E e) noexcept {
        static_assert(std::is_enum_v<E>, "E must be enum");
        write_raw(static_cast<value_type>(e));
    }

    template<typename E = value_type>
    static inline E read_as() noexcept {
        return static_cast<E>(read_raw());
    }
};
```

> 说明：上面 `mmio_reg` 的 `compiler_barrier()` 用了 `asm volatile("" ::: "memory")`，这是最轻量的编译器屏障；在 ARM Cortex-M 上如果需要确保总线顺序或缓存一致性，应在关键位置使用 `__DSB()` / `__ISB()` 或平台 SDK 提供的等价函数。

------

## 使用示例

假设我们有一个 32-bit UART 控制寄存器 `UART_CR`，地址 `0x40001000`，定义为：

- `EN` 位 0（使能），
- `MODE` 位 1~2（2 bit 模式），
- `BAUDDIV` 位 8~15（8 bit 波特率分频器）。

```cpp
// uart_regs.hpp
#include "reg.hpp"

using uart_cr_t = mmio_reg<uint32_t, 0x40001000u>;

// 强类型枚举：MODE 的可能值
enum class uart_mode : uint32_t {
    Idle = 0,
    TxRx = 1,
    TxOnly = 2,
    Reserved = 3
};

// 字段定义
using uart_en      = reg_field<uart_cr_t, 0, 1>;
using uart_mode_f  = reg_field<uart_cr_t, 1, 2>;
using uart_baud    = reg_field<uart_cr_t, 8, 8>;

// 使用
void uart_init() {
    // 设波特率分频
    uart_baud::write_raw(16);            // 直接写数值
    // 设置模式
    uart_mode_f::write(uart_mode::TxRx); // 强类型枚举
    // 使能 UART
    uart_en::write_raw(1);
}
```

优点立即可见：字段位置、宽度、合法值全部在类型系统里编码，代码读起来像文档而不是魔法位操作。

------

## 防止常见错误

1. **保证类型宽度一致**：`mmio_reg<uint32_t, ...>` 的 `uint32_t` 必须与硬件寄存器实际宽度一致，`static_assert` 能帮你在编译期发现错误。
2. **避免裸 `|=`/`&=` 在同一寄存器可能导致读后写的时序问题**：如果寄存器专门设计为“写 1 清”或“写 1 设置”，要用明确封装的 `set_bits()` / `clear_bits()` 或专用函数避免误用。
3. **考虑并发和中断**：读—改—写的操作在中断或多核环境下可能不是原子的。对于必须原子的寄存器修改，要在临界区禁中断或使用硬件提供的原子访问。
4. **内存屏障**：初始化外设或交换控制寄存器后，若需要保证后续读/写对硬件立刻生效，请使用合适的 DSB/ISB 或 `atomic_thread_fence`。
5. **别把寄存器当全局变量随便传参**：尽量保持寄存器封装为 `constexpr` 的类型/别名，便于静态审计与自动生成文档。

