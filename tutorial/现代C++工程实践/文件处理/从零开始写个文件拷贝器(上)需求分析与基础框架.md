# 现代C++实战——从零开始写个文件拷贝器(上):需求分析与基础框架

## 开篇碎碎念

我相信大家都用过cp指令。这个小系列，就是笔者打算做的一个新的现代C++实践。

文件拷贝这个需求可能是程序员生涯里最早遇到的实际问题之一。你在终端里敲个`cp`或者在图形界面拖拽文件的时候,有没有想过这背后到底发生了什么?反正我当年第一次用C写文件拷贝的时候,就觉得这事儿特别神奇——几行代码就能把几个G的电影从一个地方搬到另一个地方,虽然当时写出来的代码丑得我自己都不好意思看。

今天咱们就用现代C++来实现一个靠谱的文件拷贝器。不追求花里胡哨,但要工程上过得去,该有的功能都有,代码看着也舒服。更重要的是,我们会顺路把一些现代C++的一些特性给用上。当然，还有很多值得迭代的地方，这篇博客就是起个头。

## 需求分析:我们到底要什么?

在动手之前,得先想清楚这个拷贝器要做成什么样。一上来就开始敲代码,结果写着写着发现需求都没想明白,最后代码改来改去,跟打补丁似的。

### 核心功能

最基本的,我们需要能把文件从A点搬到B点,对吧?但这里面有几个细节得考虑:

- 首先是**分块读写**的问题。你不能一次性把整个文件读进内存——笔者真见过一下子把所有数据塞到自己的RAM或者是显卡的，直接把我的电脑干OOM了。想象一下你要拷贝一个20GB的虚拟机镜像,内存直接爆炸。所以得分批次来,每次读一块,写一块,循环往复。这个块的大小就是个学问了,太小了频繁系统调用效率低,太大了内存压力大。经验上来说,8KB到几MB之间都是合理的,我们默认用8KB,保守一点。后面感兴趣的朋友，可以自行修改和探测这个标准如何裁定。
- 其次是**错误处理**。文件操作是个充满意外的领域:源文件可能不存在,目标路径可能没有写权限,磁盘可能满了,读写过程中可能出错。一个靠谱的拷贝器不能遇到问题就崩溃,得优雅地报错并返回失败状态。
- 再者是**进度反馈**。拷贝大文件的时候,用户盯着黑屏干等是很煎熬的。我们得给个进度条,最好还能显示速度和预计剩余时间,让用户心里有数。这个功能虽然不是核心,但用户体验好很多。
- 最后是**结果验证**。拷贝完了怎么知道成功了?最简单的办法是比较源文件和目标文件的大小,虽然不如校验和那么严格,但对于大多数场景够用了。

### 接口设计

基于上面的分析,我们的`FileCopier`类接口设计得很简洁:

```cpp
class FileCopier {
public:
  explicit FileCopier(std::size_t chunk_size = 8 * 1024);
  bool copy(const std::string &src_path, const std::string &dst_path);
  void setChunkSize(std::size_t size) { chunk_size_ = size; }
private:
  std::size_t chunk_size_;
};
```

这里有几个值得说道的地方。构造函数用了`explicit`,这是个好习惯——防止编译器偷偷做隐式类型转换,避免一些莫名其妙的bug。默认块大小8KB,这是个经验值,既不会太占内存,性能也还行。

`copy`方法返回`bool`,简单明了:成功返回`true`,失败返回`false`。参数用`const std::string&`,避免不必要的拷贝。路径用`std::string`而不是`std::filesystem::path`,是考虑到接口的简单性,反正内部转换也很方便。

`setChunkSize`提供了运行时调整块大小的能力。虽然大多数时候用默认值就行,但如果你知道自己在拷贝超大文件,可以调大一点;如果内存紧张,可以调小一点。这种灵活性不费什么事,但关键时刻能派上用场。

## 技术选型:用哪些C++特性?

### 文件系统库:告别手写路径解析

C++17引入的`std::filesystem`是个宝贝。以前操作文件路径得自己处理斜杠、反斜杠、相对路径、绝对路径这些破事,现在一个`fs::path`全搞定。检查文件存在性、获取文件大小、创建目录,都是现成的API。

```cpp
namespace fs = std::filesystem;
```

这个命名空间别名我相信大家看了都是秒懂，至少，我自己写总是简写成这样，要不然太累了（尽管IDE自动补全挺好的，但是看着也很累）

### 文件流:经典但好用

`std::ifstream`和`std::ofstream`虽然是老面孔了,但在二进制模式下用来读写文件还是很靠谱的。关键是它们遵循RAII原则,析构时自动关闭文件,不用担心忘记`close()`导致资源泄漏。

打开文件时指定`std::ios::binary`,这个很关键。不加这个标志的话,在Windows上可能会对换行符做转换,导致二进制文件损坏。虽然在Linux上影响不大,但写跨平台代码就得注意这些细节。

### 动态数组:vector当缓冲区

```cpp
std::vector<char> buffer(chunk_size_);
```

用`vector`做读写缓冲区是个常见技巧。相比手动`new`和`delete`,`vector`自动管理内存,不会泄漏。而且`data()`方法可以拿到底层的连续内存指针,直接传给`read()`和`write()`,效率和原始数组一样。

注意这里直接用`chunk_size_`初始化,会把`vector`预分配到这个大小,避免后续的重新分配。

### 时间测量:chrono库

进度条需要计算速度和预估时间,这就要精确的时间测量。`std::chrono`是C++11引入的时间库,虽然语法有点啰嗦,但功能强大且类型安全。

```cpp
auto t_start = std::chrono::steady_clock::now();
```

`steady_clock`保证时间只会向前走,不受系统时间调整影响,适合测量时间间隔。`auto`类型推导在这里派上用场,不然你得写`std::chrono::time_point<std::chrono::steady_clock>`,想想就头大。

## 基础框架搭建

### 构造函数:简单但必要

```cpp
FileCopier::FileCopier(std::size_t chunk_size) : chunk_size_(chunk_size) {}
```

构造函数就一行,用成员初始化列表给`chunk_size_`赋值。这比在函数体里赋值更高效,因为是直接初始化而不是先默认构造再赋值。虽然对于`std::size_t`这种基本类型差别不大,但养成习惯总是好的。

### copy方法的整体结构

整个拷贝逻辑包在一个大的`try-catch`块里:

```cpp
bool FileCopier::copy(const std::string &src_path,
                      const std::string &dst_path) {
  try {
    // 实际拷贝逻辑
  } catch (const fs::filesystem_error &e) {
    std::cerr << "Filesystem error: " << e.what() << "\n";
    return false;
  } catch (const std::exception &e) {
    std::cerr << "Error: " << e.what() << "\n";
    return false;
  }
}
```

先捕获`filesystem_error`,这是`filesystem`库抛出的特定异常,包含更详细的错误信息。然后捕获通用的`std::exception`兜底。所有异常都转换成返回`false`,外加把错误信息打印到`stderr`。

这种错误处理策略比较保守,不会让程序崩溃,但也意味着调用者需要检查返回值。如果你觉得某些错误应该是致命的,也可以让异常继续往上抛。

### 前置检查:先确认源文件存在

```cpp
if (!fs::exists(src_path)) {
  std::cerr << "Source file does not exist: " << src_path << "\n";
  return false;
}

std::uintmax_t total_size = fs::file_size(src_path);
```

在真正开始拷贝之前,先用`fs::exists`检查源文件存不存在。这能避免后面打开文件时才发现问题,错误信息也更明确。

`fs::file_size`返回的是`std::uintmax_t`,这是个无符号整数类型,能表示非常大的文件。现在动不动就几十GB的文件,用32位的`unsigned int`早就不够了。

### 打开文件:二进制模式很重要

```cpp
std::ifstream in(src_path, std::ios::binary);
if (!in) {
  std::cerr << "Failed to open source file for reading: " << src_path << "\n";
  return false;
}

std::ofstream out(dst_path, std::ios::binary | std::ios::trunc);
if (!out) {
  std::cerr << "Failed to open destination file for writing: " << dst_path << "\n";
  return false;
}
```

输入流用`std::ios::binary`,输出流用`std::ios::binary | std::ios::trunc`。`trunc`表示如果目标文件已存在就清空它,这是拷贝操作的常见行为——你肯定不希望新内容追加到旧内容后面。

打开失败的检查用`if (!in)`,这是流对象重载的`operator bool()`,比调用`is_open()`更简洁。

### 缓冲区准备:vector的好处

```cpp
std::vector<char> buffer(chunk_size_);
```

分配一个`char`类型的`vector`,大小就是`chunk_size_`。这块内存会在函数返回时自动释放,不用操心。

为什么用`char`而不是`uint8_t`或`std::byte`?主要是因为`ifstream::read`和`ofstream::write`接受的是`char*`指针。虽然C++17有`std::byte`,但为了兼容性和简洁性,`char`仍然是常见选择。

### 进度追踪的变量

```cpp
std::uintmax_t copied = 0;
auto t_start = std::chrono::steady_clock::now();
auto last_report = t_start;
```

`copied`记录已经拷贝了多少字节,`t_start`记录开始时间用来计算总耗时和平均速度,`last_report`记录上次更新进度条的时间。

这里连续用了三个`auto`,类型推导让代码简洁很多。如果你对`auto`还不太放心,可以用IDE查看推导出的具体类型,或者用`decltype`做编译时检查。

## 小结

第一篇我们把需求分析清楚了,接口设计好了,用到的C++特性也介绍了个遍,基础框架也搭起来了。可以看到,现代C++提供的这些设施——`filesystem`、`chrono`、`vector`、RAII、异常处理——让我们能写出简洁又健壮的代码,不用再跟内存管理、路径解析这些底层细节死磕。

下一篇我们会实现核心的读写循环和进度条显示,那才是真正有意思的部分。会涉及到一些性能优化的考量,还有如何用`chrono`算速度和预估时间这些实用技巧。